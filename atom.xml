<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LLQ’s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-02-27T08:24:20.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LLQ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UITableView行高自适应+缓存优化</title>
    <link href="http://yoursite.com/2017/02/22/UITableView%E8%A1%8C%E9%AB%98%E8%87%AA%E9%80%82%E5%BA%94-%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2017/02/22/UITableView行高自适应-缓存优化/</id>
    <published>2017-02-22T08:53:36.000Z</published>
    <updated>2017-02-27T08:24:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>学习了 FDTemplateLayoutCell 后，我自己也写了一个 TableView 行高自适应加高度缓存的 Demo，本 Demo 研究实现了其中的最基本算高与缓存功能，仅供大家学习使用。</p>
</blockquote>
<p><a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="external">FDTemplateLayoutCell 原作博客</a></p>
<p>在开始之前，先让我们了解一些 Runtime 的知识，<code>objc_setAssociatedObject</code>与<code>objc_getAssociatedObject</code>这两个函数。</p>
<p>让我们来看一个例子<br><figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">     object 要持有“别的对象”的对象</div><div class="line">     <span class="built_in">key</span> 关联关键字，是一个字符串常量，是一个地址(这里注意，地址必须是不变的，地址不同但是内容相同的也不算同一个<span class="built_in">key</span>)</div><div class="line">     <span class="built_in">value</span> 也就是值</div><div class="line">     policy 这是一个枚举，你可以点进去看看这个枚举是什么：</div><div class="line">     OBJC_ASSOCIATION_ASSIGN</div><div class="line">     OBJC_ASSOCIATION_RETAIN_NONATOMIC</div><div class="line">     OBJC_ASSOCIATION_COPY_NONATOMIC</div><div class="line">     OBJC_ASSOCIATION_RETAIN</div><div class="line">     OBJC_ASSOCIATION_COPY</div><div class="line">     */</div><div class="line">    <span class="comment">//参数一：需要添加属性的对象 参数二：关联关键字（关联关键字要与get方法中的关键字相同，是一个指针类型） 参数三：属性名 参数四：枚举与@property括号中相同</span></div><div class="line">    objc_setAssociatedObject(self, @<span class="string">"name"</span>, name, OBJC_ASSOCIATION_COPY_NONATOMIC);</div></pre></td></tr></table></figure></p>
<p><code>objc_setAssociatedObject</code>这个函数的意思就是通过一个 key 为一个对象绑定另一个对象<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">     object 持有“别的对象”的对象，这里指a</div><div class="line">     key 关联关键字</div><div class="line">     */</div><div class="line">     <span class="selector-tag">objc_getAssociatedObject</span>(<span class="selector-tag">self</span>, @"<span class="keyword">name</span>");</div></pre></td></tr></table></figure></p>
<p><code>objc_getAssociatedObject</code>这个函数的意思是通过一个 key 取到一个对象绑定的那个对象</p>
<p>在上面这个例子中，我们使用这两个函数，为<code>self</code>所指的对象通过<code>@&quot;name&quot;</code>这个 key 绑定了一个值为<code>name</code>的对象<br>Runtime 就说这么多，如果小伙伴们想要更为深入的了解，请自行搜寻相关资料，至于为什么要说这两个函数，请小伙伴们继续往下面看。</p>
<blockquote>
<p>————前方高能预警————<br>下面就是本文的重点了</p>
</blockquote>
<h3 id="为-UITableViewCell-创建一个-Category-目的是为其增加两个属性"><a href="#为-UITableViewCell-创建一个-Category-目的是为其增加两个属性" class="headerlink" title="为 UITableViewCell 创建一个 Category 目的是为其增加两个属性"></a>为 UITableViewCell 创建一个 Category 目的是为其增加两个属性</h3><p>为 Cell 添加两个属性，一个用来标志此 Cell 只用来计算高度，不进行显示，另一个属性标志是否使用约束来进行计算。添加这两个属性的目的是为了保证每一种类的 Cell 都有一个相应的计算 Cell，而且此种类的计算 Cell 有且只有一个，如果你此时还有些懵逼，那请带着你的疑问继续往下看。<br>什么？你说 Category 不能添加属性？的确，Category 确实不能添加属性，但是我们有万能的 Runtime 啊，来看看我们是怎么做的<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@interface</span> UITableViewCell (HeightCacheCell)</div><div class="line"></div><div class="line"><span class="comment">//添加两个属性</span></div><div class="line"><span class="variable">@property</span> (assign, nonatomic)BOOL justForCalculate; <span class="comment">//只用来计算的标志</span></div><div class="line"></div><div class="line"><span class="variable">@property</span> (assign, nonatomic)BOOL noAuotSizeing; <span class="comment">//不依靠约束计算，只进行自适应</span></div><div class="line"></div><div class="line"><span class="variable">@end</span></div></pre></td></tr></table></figure></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@implementation</span> UITableViewCell (HeightCacheCell)</div><div class="line"></div><div class="line"></div><div class="line">#pragma mark ------ 绑定属性</div><div class="line"></div><div class="line"><span class="comment">//justForCall</span></div><div class="line">- (void)<span class="attribute">setJustForCalculate</span>:(BOOL)justForCalculate&#123;</div><div class="line">    <span class="selector-tag">objc_setAssociatedObject</span>(self, <span class="variable">@selector</span>(justForCalculate), @(justForCalculate), OBJC_ASSOCIATION_RETAIN); <span class="comment">//使用get方法名作为key</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">-</span> (BOOL)<span class="selector-tag">justForCalculate</span>&#123;</div><div class="line">    <span class="selector-tag">return</span> <span class="selector-attr">[objc_getAssociatedObject(self, _cmd) boolValue]</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//noAuotSizeing</span></div><div class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">setNoAuotSizeing</span><span class="selector-pseudo">:(BOOL)noAuotSizeing</span>&#123;</div><div class="line">    <span class="selector-tag">objc_setAssociatedObject</span>(self, <span class="variable">@selector</span>(noAuotSizeing), @(noAuotSizeing), OBJC_ASSOCIATION_RETAIN);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">-</span> (BOOL)<span class="selector-tag">noAuotSizeing</span>&#123;</div><div class="line">    <span class="selector-tag">return</span> <span class="selector-attr">[objc_getAssociatedObject(self, _cmd) boolValue]</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@<span class="selector-tag">end</span></div></pre></td></tr></table></figure>
<p>重写这两个属性的 get set 方法，并使用刚才学到的两个 Runtime 方法，为 UITableViewCell 绑定了两个对象，这样一来，我们就变相的为 UITableViewCell 添加了两个属性</p>
<h3 id="创建一个-Cache-类，用来缓存相应-Cell-的高度"><a href="#创建一个-Cache-类，用来缓存相应-Cell-的高度" class="headerlink" title="创建一个 Cache 类，用来缓存相应 Cell 的高度"></a>创建一个 Cache 类，用来缓存相应 Cell 的高度</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="variable">@interface</span> <span class="attribute">HeightCache </span>: NSObject</div><div class="line"></div><div class="line"><span class="variable">@property</span> (strong, nonatomic)NSMutableDictionary *heightCacheDicV; <span class="comment">//竖直行高缓存字典</span></div><div class="line"><span class="variable">@property</span> (strong, nonatomic)NSMutableDictionary *heightCacheDicH; <span class="comment">//水平行高缓存字典</span></div><div class="line"><span class="variable">@property</span> (strong, nonatomic)NSMutableDictionary *heightCacheDicCurrent; <span class="comment">//当前行高缓存字典</span></div><div class="line"></div><div class="line"><span class="comment">//制作key</span></div><div class="line"><span class="selector-tag">-</span> (NSString *)<span class="selector-tag">makeKeyWithIdentifier</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">identifier</span> <span class="selector-tag">indexPath</span><span class="selector-pseudo">:(NSIndexPath</span> *)<span class="selector-tag">indexPath</span>;</div><div class="line"></div><div class="line"><span class="comment">//判断高度是否存在</span></div><div class="line"><span class="selector-tag">-</span> (BOOL)<span class="selector-tag">existInCacheByKey</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">key</span>;</div><div class="line"></div><div class="line"><span class="comment">//查找高度缓存</span></div><div class="line"><span class="selector-tag">-</span> (CGFloat)<span class="selector-tag">heightFromCacheWithKey</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">key</span>;</div><div class="line"></div><div class="line"><span class="comment">//缓存</span></div><div class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">cacheHieght</span><span class="selector-pseudo">:(CGFloat)hieght</span> <span class="selector-tag">key</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">key</span>;</div><div class="line"></div><div class="line">@<span class="selector-tag">end</span></div></pre></td></tr></table></figure>
<p>创建 HeightCache 这样一个类，为其添加了三个字典作为属性，分别存储在手机横屏竖屏下的 Cell 缓存高度，Current 字典为当前手机屏幕状态下的缓存字典，在它的懒加载方法中，我们将判断使用的是横屏缓存字典还是竖屏缓存字典。暴露四个方法，分别是“制作从缓存字典中取缓存高度的 key”、“判断此 key 下是否有缓存高度”、“通过 key 取出缓存高度”、“通过 key 将对应高度缓存”这四个方法。<br>实现相当简单，这里直接贴上代码，不做过多解释。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HeightCache</span></span></div><div class="line"></div><div class="line"><span class="comment">//制作key</span></div><div class="line">- (<span class="built_in">NSString</span> *)makeKeyWithIdentifier:(<span class="built_in">NSString</span> *)identifier indexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@S%ldR%ld"</span>,identifier,indexPath.section,indexPath.row];</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//判断高度是否存在</span></div><div class="line">- (<span class="built_in">BOOL</span>)existInCacheByKey:(<span class="built_in">NSString</span> *)key&#123;</div><div class="line">    <span class="built_in">NSNumber</span> * value = [<span class="keyword">self</span>.heightCacheDicCurrent objectForKey:key];</div><div class="line">    <span class="keyword">return</span> (value &amp;&amp; ![value isEqualToNumber:@<span class="number">-1</span>]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//取出缓存的高度</span></div><div class="line">- (<span class="built_in">CGFloat</span>)heightFromCacheWithKey:(<span class="built_in">NSString</span> *)key&#123;</div><div class="line">    <span class="built_in">NSNumber</span> *value = [<span class="keyword">self</span>.heightCacheDicCurrent objectForKey:key];</div><div class="line">    <span class="keyword">return</span> [value floatValue];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//缓存</span></div><div class="line">- (<span class="keyword">void</span>)cacheHieght:(<span class="built_in">CGFloat</span>)hieght key:(<span class="built_in">NSString</span> *)key&#123;</div><div class="line">    [<span class="keyword">self</span>.heightCacheDicCurrent setObject:@(hieght) forKey:key];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//lazy</span></div><div class="line">- (<span class="built_in">NSMutableDictionary</span> *)heightCacheDicH&#123;</div><div class="line">    <span class="keyword">if</span> (!_heightCacheDicH) &#123;</div><div class="line">        _heightCacheDicH = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> _heightCacheDicH;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSMutableDictionary</span> *)heightCacheDicV&#123;</div><div class="line">    <span class="keyword">if</span> (!_heightCacheDicV) &#123;</div><div class="line">        _heightCacheDicV = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> _heightCacheDicV;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//根据横竖屏状态选择字典</span></div><div class="line">- (<span class="built_in">NSMutableDictionary</span> *)heightCacheDicCurrent&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">UIDeviceOrientationIsPortrait</span>([<span class="built_in">UIDevice</span> currentDevice].orientation)?<span class="keyword">self</span>.heightCacheDicV:<span class="keyword">self</span>.heightCacheDicH;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<h3 id="重点！创建-UITableView-的-Category-，计算-Cell-高度并缓存"><a href="#重点！创建-UITableView-的-Category-，计算-Cell-高度并缓存" class="headerlink" title="重点！创建 UITableView 的 Category ，计算 Cell 高度并缓存"></a>重点！创建 UITableView 的 Category ，计算 Cell 高度并缓存</h3><h4 id="我们首先为-UITableView-添加一个-HeightCache-作为属性，方便用来存储高度缓存，这里还是用-Runtime-的方法"><a href="#我们首先为-UITableView-添加一个-HeightCache-作为属性，方便用来存储高度缓存，这里还是用-Runtime-的方法" class="headerlink" title="我们首先为 UITableView 添加一个 HeightCache 作为属性，方便用来存储高度缓存，这里还是用 Runtime 的方法"></a>我们首先为 UITableView 添加一个 HeightCache 作为属性，方便用来存储高度缓存，这里还是用 Runtime 的方法</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#pragma mark ------ 绑定属性</span></div><div class="line"></div><div class="line">- (HeightCache *)heightCache&#123;</div><div class="line">    HeightCache *<span class="keyword">cache </span>= objc_getAssociatedObject(self, _cmd)<span class="comment">;</span></div><div class="line">    if (!<span class="keyword">cache) </span>&#123;</div><div class="line">        <span class="keyword">cache </span>= [[HeightCache alloc] init]<span class="comment">;</span></div><div class="line">        objc_setAssociatedObject(self, _cmd, <span class="keyword">cache, </span>OBJC_ASSOCIATION_RETAIN_NONATOMIC)<span class="comment">;</span></div><div class="line">    &#125;</div><div class="line">    return <span class="keyword">cache;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setHeightCache:(HeightCache *)heightCache&#123;</div><div class="line">    </div><div class="line">    objc_setAssociatedObject(self, @selector(heightCache), heightCache, OBJC_ASSOCIATION_RETAIN_NONATOMIC)<span class="comment">;</span></div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="从复用池中获取一个用于计算的-Cell"><a href="#从复用池中获取一个用于计算的-Cell" class="headerlink" title="从复用池中获取一个用于计算的 Cell"></a>从复用池中获取一个用于计算的 Cell</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取一个用于计算高度的Cell</span></div><div class="line">- (__kindof <span class="built_in">UITableViewCell</span> *)LLQ_CalculateCellWithIdentifier:(<span class="built_in">NSString</span> *)identifier&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!identifier.length) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//runtime获取一个存储cell的字典</span></div><div class="line">    <span class="built_in">NSMutableDictionary</span> &lt;<span class="built_in">NSString</span> *, <span class="built_in">UITableViewCell</span> *&gt; *dicForTheUniqueCalCell = objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</div><div class="line">    <span class="comment">//如果取不到，就绑定一个</span></div><div class="line">    <span class="keyword">if</span> (!dicForTheUniqueCalCell) &#123;</div><div class="line">        dicForTheUniqueCalCell = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</div><div class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, _cmd, dicForTheUniqueCalCell, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//取出cell，从绑定的字典取用</span></div><div class="line">    <span class="built_in">UITableViewCell</span> *cell = dicForTheUniqueCalCell[identifier];</div><div class="line">    <span class="keyword">if</span> (!cell) &#123;</div><div class="line">        cell = [<span class="keyword">self</span> dequeueReusableCellWithIdentifier:identifier];</div><div class="line">        cell.contentView.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>; <span class="comment">//设置为NO才能用代码使用AutoLayout</span></div><div class="line">        cell.justForCalculate = <span class="literal">YES</span>; <span class="comment">//设置只计算</span></div><div class="line">        dicForTheUniqueCalCell[identifier] = cell;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> cell;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此方法中为 UITableView 绑定了一个字典，目的是存储某一种类的 Cell，而区分 Cell 种类的办法就是通过 Cell 的重用标识符。通过重用标识符从字典中获取 Cell，如果获取不到，就从 TableView 的复用池中取出一个此种类的 Cell，并设置只计算属性，存入绑定的字典，这样一来，我们就保证了每种类的 Cell 有且只有一个用来计算。要注意的是，在实际项目使用中我们必须使用<code>-registerClass:forCellReuseIdentifier:</code> 或 <code>-registerNib:forCellReuseIdentifier:</code>其中之一的方法对 Cell 进行注册。</p>
<h4 id="计算-Cell-的高度"><a href="#计算-Cell-的高度" class="headerlink" title="计算 Cell 的高度"></a>计算 Cell 的高度</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//计算cell高度</span></div><div class="line">- (<span class="built_in">CGFloat</span>)LLQ_CalculateCellHeightWithCell:(<span class="built_in">UITableViewCell</span> *)cell&#123;</div><div class="line">    </div><div class="line">    <span class="built_in">CGFloat</span> width = <span class="keyword">self</span>.bounds.size.width;</div><div class="line">    </div><div class="line">    <span class="comment">//根据辅助视图，调整宽度</span></div><div class="line">    <span class="keyword">if</span> (cell.accessoryView) &#123;</div><div class="line">        width -= cell.accessoryView.bounds.size.width + <span class="number">16</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">CGFloat</span> accessoryWith[] = &#123;</div><div class="line">            [<span class="built_in">UITableViewCellAccessoryNone</span>] = <span class="number">0</span>,</div><div class="line">            [<span class="built_in">UITableViewCellAccessoryCheckmark</span>] = <span class="number">40</span>,</div><div class="line">            [<span class="built_in">UITableViewCellAccessoryDetailButton</span>] = <span class="number">48</span>,</div><div class="line">            [<span class="built_in">UITableViewCellAccessoryDisclosureIndicator</span>] = <span class="number">34</span>,</div><div class="line">            [<span class="built_in">UITableViewCellAccessoryDetailDisclosureButton</span>] = <span class="number">68</span>,</div><div class="line">        &#125;;</div><div class="line">        width -= accessoryWith[cell.accessoryType];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">CGFloat</span> height = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//非自适应模式，添加约束后计算约束后高度</span></div><div class="line">    <span class="keyword">if</span> (!cell.noAuotSizeing &amp;&amp; width&gt;<span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">NSLayoutConstraint</span> *widthConstraint = [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:cell.contentView attribute:<span class="built_in">NSLayoutAttributeWidth</span> relatedBy:<span class="built_in">NSLayoutRelationEqual</span> toItem:<span class="literal">nil</span> attribute:<span class="built_in">NSLayoutAttributeNotAnAttribute</span> multiplier:<span class="number">1.0</span> constant:width];</div><div class="line">        [cell.contentView addConstraint:widthConstraint];</div><div class="line">        <span class="comment">//根据约束计算高度</span></div><div class="line">        height = [cell.contentView systemLayoutSizeFittingSize:<span class="built_in">UILayoutFittingCompressedSize</span>].height;</div><div class="line">        [cell.contentView removeConstraint:widthConstraint]; <span class="comment">//移除约束</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//如果约束添加错误，可能导致计算结果为0，则采用自适应模式计算约束</span></div><div class="line">    <span class="keyword">if</span> (height == <span class="number">0</span>) &#123;</div><div class="line">        height = [cell sizeThatFits:<span class="built_in">CGSizeMake</span>(width, <span class="number">0</span>)].height;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//还是为0，默认高度</span></div><div class="line">    <span class="keyword">if</span> (height == <span class="number">0</span>) &#123;</div><div class="line">        height = <span class="number">44</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.separatorStyle != <span class="built_in">UITableViewCellSeparatorStyleNone</span>) &#123;</div><div class="line">        height += <span class="number">1.0</span>/[<span class="built_in">UIScreen</span> mainScreen].scale;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> height;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先计算 Cell 的 width，如果有辅助视图，我们还要修正 width，判断是否是 AutoSizeing 模式，来决定使用哪种方式算 Cell 的高度，如果使用约束算高，就是通过添加一个我们算好的固定 width 的约束，从而得出 Cell 的高度。能够这样做的前提是我们在 xib 中使用的 autolayout 约束正确。在最后判断一下有无分割线，做最后一次高度修正。</p>
<h4 id="将上面两个方法整合，给-Cell-填充数据后计算出当前-Cell-的高度"><a href="#将上面两个方法整合，给-Cell-填充数据后计算出当前-Cell-的高度" class="headerlink" title="将上面两个方法整合，给 Cell 填充数据后计算出当前 Cell 的高度"></a>将上面两个方法整合，给 Cell 填充数据后计算出当前 Cell 的高度</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//取出cell并对cell进行操作，然后计算高度</span></div><div class="line">- (<span class="built_in">CGFloat</span>)LLQ_CalculateCellWithIdentifier:(<span class="built_in">NSString</span> *)identifier configuration:(<span class="keyword">void</span>(^)(<span class="keyword">id</span> cell))configuration&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!identifier.length) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">UITableViewCell</span> *cell = [<span class="keyword">self</span> LLQ_CalculateCellWithIdentifier:identifier];</div><div class="line">    [cell prepareForReuse]; <span class="comment">//放回重用池</span></div><div class="line">    <span class="keyword">if</span> (configuration) &#123;</div><div class="line">        configuration(cell);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> LLQ_CalculateCellHeightWithCell:cell];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先获取一个 Cell 然后将其放回复用池（因为我们在取 Cell 的方法中没有将其放回），然后给 Cell 填充数据，这里使用了 block 将 Cell 传递到外界，填充完数据后使用算高方法计算高度。</p>
<h4 id="计算高度，并将计算的高度缓存，本方法暴露给外界共外界调用"><a href="#计算高度，并将计算的高度缓存，本方法暴露给外界共外界调用" class="headerlink" title="计算高度，并将计算的高度缓存，本方法暴露给外界共外界调用"></a>计算高度，并将计算的高度缓存，本方法暴露给外界共外界调用</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//供外部调用的方法</span></div><div class="line">- (<span class="built_in">CGFloat</span>)LLQ_CalculateCellWithIdentifer:(<span class="built_in">NSString</span> *)identifier indexPath:(<span class="built_in">NSIndexPath</span> *)indexPath configuration:(<span class="keyword">void</span>(^)(<span class="keyword">id</span> cell))configuration&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.bounds.size.width != <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!identifier.length || !indexPath) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">NSString</span> *key = [<span class="keyword">self</span>.heightCache makeKeyWithIdentifier:identifier indexPath:indexPath];</div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.heightCache existInCacheByKey:key]) &#123;  <span class="comment">//如果有缓存，就取出缓存</span></div><div class="line">            <span class="keyword">return</span> [<span class="keyword">self</span>.heightCache heightFromCacheWithKey:key]; <span class="comment">//从字典中取出高度</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//没有缓存，计算缓存</span></div><div class="line">        <span class="built_in">CGFloat</span> height = [<span class="keyword">self</span> LLQ_CalculateCellWithIdentifier:identifier configuration:configuration];</div><div class="line">        <span class="comment">//并进行缓存</span></div><div class="line">        [<span class="keyword">self</span>.heightCache cacheHieght:height key:key];</div><div class="line">        <span class="keyword">return</span> height;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先使用重用标识符和 IndexPath 制作高度缓存的 key，这样制作出的 key 就能保证种类、组、行的唯一性，然后使用这个 key 去取缓存的高度，若没有缓存高度就进行计算。</p>
<blockquote>
<p><strong>本 Demo 实现了 TableView 的行高自适应与行高缓存，这只是 FDTemplateLayoutCell 的一部分主要功能，在项目复杂情况下不够适用，比如在移动一个单元格，删除一个单元格等情况时本 Demo 没有相应的处理实现，如果各位小伙伴项目需要，请直接使用 <a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="external">FDTemplateLayoutCell</a>。</strong></p>
</blockquote>
<p><strong>本 Demo 仅供学习使用。</strong></p>
<p>最后，我还是会按照惯例把 Demo 共享给大家<br><a href="https://github.com/li1024316925/UITableviewHeightCache" target="_blank" rel="external">Demo点这里！点这里！点这里！</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;学习了 FDTemplateLayoutCell 后，我自己也写了一个 TableView 行高自适应加高度缓存的 Demo，本 Demo 研究实现了其中的最基本算高与缓存功能，仅供大家学习使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a h
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>封装一个网络图片加载与缓存Category</title>
    <link href="http://yoursite.com/2017/02/18/%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%B8%8E%E7%BC%93%E5%AD%98Category/"/>
    <id>http://yoursite.com/2017/02/18/封装一个网络图片加载与缓存Category/</id>
    <published>2017-02-18T07:54:46.000Z</published>
    <updated>2017-02-27T08:27:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>又有好多天没写博客了，Markdown语法都快忘了….</p>
<p><strong>步入正题，赶紧来看看我们今天要搞的事情</strong></p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1393645-09995ecaf5360971.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/340" alt="偷偷告诉你，我们要搞事情啦.jpg"></p>
<blockquote>
<p>旁友，听说过 SDWebImage 伐？今天我们要搞得事情就是做一个类似的 UIImageView Category，网络图片的加载与缓存（什么？取代 SD ？旁友你想多了）</p>
</blockquote>
<h4 id="首先说一下思路"><a href="#首先说一下思路" class="headerlink" title="首先说一下思路"></a>首先说一下思路</h4><p>如果页面中有多个 ImageView 我们每次加载这个页面都要重新去网络请求图片的话速度是比较慢的，而且也是特别消耗性能的，所以我们这个 Category 不光是从网络加载图片，我们的另一个目的是将第一次从网络加载的图片缓存到内存与硬盘（就是存到手机的闪存，也就是本地化保存，为了方便以下统称存到硬盘），下次取用的时候先从内存中查找，如果没有再查找硬盘，还是没有再从网络加载。</p>
<h4 id="开始第一步，首先创建之后所需要的缓存内存与硬盘的工具类"><a href="#开始第一步，首先创建之后所需要的缓存内存与硬盘的工具类" class="headerlink" title="开始第一步，首先创建之后所需要的缓存内存与硬盘的工具类"></a>开始第一步，首先创建之后所需要的缓存内存与硬盘的工具类</h4><h6 id="内存存储工具类"><a href="#内存存储工具类" class="headerlink" title="内存存储工具类"></a>内存存储工具类</h6><p>内存存储，实际上就是把下载好的图片存到可变字典，我这边使用了一个单例来保存这个字典<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WebImageMemory</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="comment">//使用字典存储</span></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">NSMutableDictionary</span> *imageDic;</div><div class="line"></div><div class="line"><span class="comment">//单例方法</span></div><div class="line">+ (WebImageMemory *)shareInstancy;</div><div class="line"></div><div class="line"><span class="comment">//内存存储的方法</span></div><div class="line">- (<span class="keyword">void</span>)setImageToMemoryWithImage:(<span class="built_in">UIImage</span> *)image withName:(<span class="built_in">NSString</span> *)imageName;</div><div class="line"></div><div class="line"><span class="comment">//内存读取的方法</span></div><div class="line">- (<span class="built_in">UIImage</span> *)getImageFormMenoryWithName:(<span class="built_in">NSString</span> *)imageName;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>下面是实现代码<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> WebImageMemory *webImgMemory;</div><div class="line"><span class="comment">//单例方法</span></div><div class="line">+ (WebImageMemory *)shareInstancy&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//GCD只执行一次的方法</span></div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        </div><div class="line">        webImgMemory = [[WebImageMemory alloc] init];</div><div class="line">        </div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> webImgMemory;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//懒加载</span></div><div class="line">- (<span class="built_in">NSMutableDictionary</span> *)imageDic&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!_imageDic) &#123;</div><div class="line">        </div><div class="line">        _imageDic = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> _imageDic;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//存储的方法</span></div><div class="line">- (<span class="keyword">void</span>)setImageToMemoryWithImage:(<span class="built_in">UIImage</span> *)image withName:(<span class="built_in">NSString</span> *)imageName&#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.imageDic setObject:image forKey:imageName];</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//读取的方法</span></div><div class="line">- (<span class="built_in">UIImage</span> *)getImageFormMenoryWithName:(<span class="built_in">NSString</span> *)imageName&#123;</div><div class="line">    </div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span>.imageDic objectForKey:imageName];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (image) &#123;</div><div class="line">        <span class="keyword">return</span> image;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个内存存储相当简单，我们再看看硬盘存储</p>
<h6 id="硬盘存储工具类"><a href="#硬盘存储工具类" class="headerlink" title="硬盘存储工具类"></a>硬盘存储工具类</h6><p>同样的，我也是用一个单例来管理存储的一些相关操作，并保存本地存储的文件路径<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WebImageCaches</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">NSString</span> *imagePath;</div><div class="line"></div><div class="line"><span class="comment">//单例</span></div><div class="line">+ (WebImageCaches *)shareInstance;</div><div class="line"></div><div class="line"><span class="comment">//硬盘存储的方法</span></div><div class="line">- (<span class="keyword">void</span>)setImageToCachesWithImageData:(<span class="built_in">NSData</span> *)imageData withImageName:(<span class="built_in">NSString</span> *)imageName;</div><div class="line"></div><div class="line"><span class="comment">//硬盘缓存的方法</span></div><div class="line">- (<span class="built_in">UIImage</span> *)getImageFromCachesWithName:(<span class="built_in">NSString</span> *)imageName;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>实现部分，这边用保存好的本地路径拼接上文件名，作为保存图片文件的最终路径<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> WebImageCaches *imageCaches;</div><div class="line"><span class="comment">//单例方法</span></div><div class="line">+ (WebImageCaches *)shareInstance&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        </div><div class="line">        imageCaches = [[WebImageCaches alloc] init];</div><div class="line">        </div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> imageCaches;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//复写imagePath的get方法，在第一次get时给imagePath赋值</span></div><div class="line">- (<span class="built_in">NSString</span> *)imagePath&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!_imagePath) &#123;</div><div class="line">        <span class="comment">//获取文件存储路径</span></div><div class="line">        _imagePath = [<span class="built_in">NSHomeDirectory</span>() stringByAppendingString:<span class="string">@"/Library/Caches/WebImageCaches/"</span>];</div><div class="line">        <span class="comment">//通过文件管家创建该路径</span></div><div class="line">        [[<span class="built_in">NSFileManager</span> defaultManager] createDirectoryAtPath:_imagePath withIntermediateDirectories:<span class="literal">YES</span> attributes:<span class="literal">nil</span> error:<span class="literal">nil</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> _imagePath;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//存入硬盘</span></div><div class="line">- (<span class="keyword">void</span>)setImageToCachesWithImageData:(<span class="built_in">NSData</span> *)imageData withImageName:(<span class="built_in">NSString</span> *)imageName&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//拼接文件路径</span></div><div class="line">    <span class="built_in">NSString</span> *filePath = [<span class="keyword">self</span>.imagePath stringByAppendingString:imageName];</div><div class="line">    <span class="comment">//使用文件管家将data存储</span></div><div class="line">    [[<span class="built_in">NSFileManager</span> defaultManager] createFileAtPath:filePath contents:imageData attributes:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//从硬盘读取</span></div><div class="line">- (<span class="built_in">UIImage</span> *)getImageFromCachesWithName:(<span class="built_in">NSString</span> *)imageName&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//拼接文件路径</span></div><div class="line">    <span class="built_in">NSString</span> *filePath = [<span class="keyword">self</span>.imagePath stringByAppendingString:imageName];</div><div class="line">    <span class="comment">//取出图片</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithContentsOfFile:filePath];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> image;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="第二步，创建-UIImageView-的-Category"><a href="#第二步，创建-UIImageView-的-Category" class="headerlink" title="第二步，创建 UIImageView 的 Category"></a>第二步，创建 UIImageView 的 Category</h4><h6 id="使用-MD5-加密图片链接作为图片名"><a href="#使用-MD5-加密图片链接作为图片名" class="headerlink" title="使用 MD5 加密图片链接作为图片名"></a>使用 MD5 加密图片链接作为图片名</h6><p>这边记得要导入<code>#import &lt;CommonCrypto/CommonCrypto.h&gt;</code><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//MD5加密</span></div><div class="line">- (<span class="built_in">NSString</span> *)md5:(<span class="built_in">NSString</span> *)str&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *cStr = [str UTF8String];</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> schemes[CC_MD5_DIGEST_LENGTH];</div><div class="line">    </div><div class="line">    <span class="comment">//MD5加密函数</span></div><div class="line">    CC_MD5(cStr, (<span class="built_in">UInt32</span>)strlen(cStr), schemes);</div><div class="line">    </div><div class="line">    <span class="built_in">NSMutableString</span> *md5Str = [[<span class="built_in">NSMutableString</span> alloc] init];</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CC_MD5_DIGEST_LENGTH; i ++) &#123;</div><div class="line">        </div><div class="line">        [md5Str appendFormat:<span class="string">@"%02x"</span>,schemes[i]];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    [md5Str appendFormat:<span class="string">@".png"</span>];</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">return</span> md5Str;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h6 id="暴露一个获取图片的方法"><a href="#暴露一个获取图片的方法" class="headerlink" title="暴露一个获取图片的方法"></a>暴露一个获取图片的方法</h6><p><code>- (void)setimageWithURL:(NSString *)urlString;</code><br>来看看它的实现<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setimageWithURL:(<span class="built_in">NSString</span> *)urlString&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//MD5加密</span></div><div class="line">    <span class="built_in">NSString</span> *imageName = [<span class="keyword">self</span> md5:urlString];</div><div class="line">    </div><div class="line">    <span class="comment">//首先从内存中读取</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [[WebImageMemory shareInstancy] getImageFormMenoryWithName:imageName];</div><div class="line">    </div><div class="line">    <span class="comment">//如果能从内存取到值，就直接加载</span></div><div class="line">    <span class="keyword">if</span> (image) &#123;</div><div class="line">        <span class="keyword">self</span>.image = image;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"从内存加载"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//其次从硬盘中读取</span></div><div class="line">    <span class="built_in">UIImage</span> *image2 = [[WebImageCaches shareInstance] getImageFromCachesWithName:imageName];</div><div class="line">    </div><div class="line">    <span class="comment">//如果能从硬盘中取到，就直接加载</span></div><div class="line">    <span class="keyword">if</span> (image2) &#123;</div><div class="line">        <span class="keyword">self</span>.image = image2;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"从硬盘加载"</span>);</div><div class="line">        <span class="comment">//存入内存</span></div><div class="line">        [[WebImageMemory shareInstancy] setImageToMemoryWithImage:image2 withName:imageName];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//创建一个串行队列，执行下载任务</span></div><div class="line">    <span class="built_in">dispatch_queue_t</span> download_queu = dispatch_queue_create(<span class="string">"download_queue"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">    </div><div class="line">    <span class="comment">//异步添加任务  开辟子线程</span></div><div class="line">    <span class="built_in">dispatch_async</span>(download_queu, ^&#123;</div><div class="line">       </div><div class="line">        <span class="comment">//下载任务</span></div><div class="line">        <span class="built_in">NSURL</span> *imageURL = [<span class="built_in">NSURL</span> URLWithString:urlString];</div><div class="line">        <span class="built_in">NSData</span> *imageData = [<span class="built_in">NSData</span> dataWithContentsOfURL:imageURL];</div><div class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:imageData];</div><div class="line">        </div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"下载"</span>);</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (image == <span class="literal">nil</span>) &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"图片下载失败"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//获取主队列向主队列异步添加加载图片的任务</span></div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">           </div><div class="line">            <span class="keyword">self</span>.image = image;</div><div class="line">            <span class="comment">//将网路下载的图片存入内存</span></div><div class="line">            [[WebImageMemory shareInstancy] setImageToMemoryWithImage:image withName:imageName];</div><div class="line">            </div><div class="line">            <span class="comment">//存入硬盘</span></div><div class="line">            [[WebImageCaches shareInstance] setImageToCachesWithImageData:imageData withImageName:imageName];</div><div class="line">            </div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先将图片链接经过 MD5 加密后作为文件名去查找内存字典中有没有保存有的话直接取出来，显示到 UI，没有的话查找硬盘中与没有保存图片文件，有的话取出来更新到 UI，如果还是没有，我们创建一条串行队列，这样保证图片是一个个加载的，向这个串行队列异步添加下载任务，下载完成后保存到内存与硬盘</p>
<blockquote>
<p>到此为止，一个简单的网络图片加载就封装完成了，不过还是有很多的缺陷，比如缓存到内存的图片过多、在 TableView 中使用会不会造成卡顿等等，这篇文章只是介绍了一个简单的网络图片缓存思路，直接用在项目中的话还需要大量的完善</p>
</blockquote>
<p>这个 demo 虽然很简单，上面写的也很清楚，但是按照惯例，我还是把GitHub 地址附上<br><a href="https://github.com/li1024316925/Webimage" target="_blank" rel="external">demo点这里点这里点这里</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;又有好多天没写博客了，Markdown语法都快忘了….&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步入正题，赶紧来看看我们今天要搞的事情&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>纵向横向瀑布流</title>
    <link href="http://yoursite.com/2017/01/16/%E7%BA%B5%E5%90%91%E6%A8%AA%E5%90%91%E7%80%91%E5%B8%83%E6%B5%81/"/>
    <id>http://yoursite.com/2017/01/16/纵向横向瀑布流/</id>
    <published>2017-01-16T10:12:34.000Z</published>
    <updated>2017-02-27T08:25:07.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>本篇文章主要介绍瀑布流的实现原理，demo以原理为主，随便写了写，封装性不好，如果拿去直接用需要修改的地方是比较多的。所以此文章仅供学习，想直接用的小伙伴需要多费些功夫了。</p>
</blockquote>
<p>话不多说，先看看效果图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1393645-7e63c180c88ffcc2.gif?imageMogr2/auto-orient/strip" alt="瀑布流.gif"></p>
<h3 id="首先介绍一下用到的控件"><a href="#首先介绍一下用到的控件" class="headerlink" title="首先介绍一下用到的控件"></a>首先介绍一下用到的控件</h3><p>这里我们用的是 <code>UICollectionView</code> 它的优点咱们不多说，最大的优点单元格可复用，当然你非要用 <code>UIView</code> 循环创建那我也没话说。<br>要用 <code>UICollectionView</code> 实现一个瀑布流，只用代理方法是不可能的，这里我们要用到 <code>UICollectionView</code> 的布局类 <code>UICollectionViewFlowLayout</code>。<br>我们要去继承 <code>UICollectionViewFlowLayout</code> 自定义一个新的布局类，瀑布流的实现就是依靠我们自定义的布局类。</p>
<h3 id="再来看看自定义布局类中用到的方法"><a href="#再来看看自定义布局类中用到的方法" class="headerlink" title="再来看看自定义布局类中用到的方法"></a>再来看看自定义布局类中用到的方法</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//当collectionView的frame有新改变(发生移动)时调用，其若返回YES则重新布局</span></div><div class="line">- (<span class="built_in">BOOL</span>)shouldInvalidateLayoutForBoundsChange:(<span class="built_in">CGRect</span>)newBounds&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  准备好布局时调用</div><div class="line"> *  布局准备方法 当collectionView的布局发生变化时 会被调用</div><div class="line"> *  通常是做布局的准备工作 itemSize.....</div><div class="line"> *  UICollectionView 的 contentSize 是根据 itemSize 动态计算出来的</div><div class="line">调用顺序 ···· 1</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)prepareLayout&#123; </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//返回collectionView视图中所有视图的属性(UICollectionViewLayoutAttributes)数组</span></div><div class="line">调用顺序 ···· <span class="number">3</span>（每个应的item属性方法调用完后还会调用此方法）</div><div class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">UICollectionViewLayoutAttributes</span> *&gt; *)layoutAttributesForElementsInRect:(<span class="built_in">CGRect</span>)rect&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//返回indexPath对应item的属性</span></div><div class="line">调用顺序 ···· <span class="number">4</span></div><div class="line">- (<span class="built_in">UICollectionViewLayoutAttributes</span> *)layoutAttributesForItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//设置collectionView的可显示范围</span></div><div class="line">调用顺序 ···· <span class="number">2</span></div><div class="line">- (<span class="built_in">CGSize</span>)collectionViewContentSize&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">CGSizeMake</span>(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>瀑布流的原理就是手动计算每个 item 的 frame 然后交给 collectionView 布局类的内容视图（包括头尾视图、每个单元格等）属性数组。</p>
<h3 id="先看比较简单的，垂直瀑布流的实现步骤"><a href="#先看比较简单的，垂直瀑布流的实现步骤" class="headerlink" title="先看比较简单的，垂直瀑布流的实现步骤"></a>先看比较简单的，垂直瀑布流的实现步骤</h3><h4 id="1-复写-prepareLayout-方法，准备工作，此时的-collectionView-就像一个空的-scrollView-所有的-item-都需要我们自己手动的确定他的-frame-就像一个画板，我们需要把视图都画在这个画板上。"><a href="#1-复写-prepareLayout-方法，准备工作，此时的-collectionView-就像一个空的-scrollView-所有的-item-都需要我们自己手动的确定他的-frame-就像一个画板，我们需要把视图都画在这个画板上。" class="headerlink" title="1.复写 prepareLayout 方法，准备工作，此时的 collectionView 就像一个空的 scrollView 所有的 item 都需要我们自己手动的确定他的 frame 就像一个画板，我们需要把视图都画在这个画板上。"></a>1.复写 <code>prepareLayout</code> 方法，准备工作，此时的 collectionView 就像一个空的 scrollView 所有的 item 都需要我们自己手动的确定他的 frame 就像一个画板，我们需要把视图都画在这个画板上。</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  准备好布局时调用</div><div class="line"> *  布局准备方法 当collectionView的布局发生变化时 会被调用</div><div class="line"> *  通常是做布局的准备工作 itemSize.....</div><div class="line"> *  UICollectionView 的 contentSize 是根据 itemSize 动态计算出来的</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)prepareLayout&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//item的最小间距</span></div><div class="line">    <span class="built_in">CGFloat</span> space = <span class="keyword">self</span>.minimumInteritemSpacing;</div><div class="line">    <span class="built_in">CGFloat</span> contentSize = <span class="keyword">self</span>.collectionView.bounds.size.width - <span class="keyword">self</span>.sectionInset.left - <span class="keyword">self</span>.sectionInset.right;</div><div class="line">    <span class="comment">//每个单元格的宽度</span></div><div class="line">    <span class="built_in">CGFloat</span> itemWidth = (contentSize - (space * (<span class="keyword">self</span>.lineNum<span class="number">-1</span>)))/<span class="keyword">self</span>.lineNum;</div><div class="line">    <span class="comment">//根据宽度计算每个单元格的属性</span></div><div class="line">    [<span class="keyword">self</span> computeAttributesWithItemWidth:itemWidth];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>计算每个单元格的 attributes 方法，我们保存每一列的总高度，在创建每个单元格的 attributes 时挑选最短的那一列，把当前单元格添加到这个最短列<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)computeAttributesWithItemWidth:(<span class="built_in">CGFloat</span>)width&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//存储每列个数和每列总高度的数组</span></div><div class="line">    <span class="built_in">CGFloat</span> columnHeight[<span class="keyword">self</span>.lineNum];</div><div class="line">    <span class="built_in">CGFloat</span> columnNum[<span class="keyword">self</span>.lineNum];</div><div class="line">    <span class="comment">//初始化数组</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">self</span>.lineNum; i ++) &#123;</div><div class="line">        columnNum[i] = <span class="number">0</span>;</div><div class="line">        <span class="comment">//sectionInset  UIEdgeInsets类型  边距</span></div><div class="line">        columnHeight[i] = <span class="keyword">self</span>.sectionInset.top;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//循环创建每个单元格的 attributes</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">self</span>.dataList.count; i ++) &#123;</div><div class="line">        <span class="keyword">int</span> index = [<span class="keyword">self</span> computerMinHeightWithArray:columnHeight];</div><div class="line">        <span class="built_in">UICollectionViewLayoutAttributes</span> *attributes = [<span class="built_in">UICollectionViewLayoutAttributes</span> layoutAttributesForCellWithIndexPath:[<span class="built_in">NSIndexPath</span> indexPathForItem:i inSection:<span class="number">0</span>]];</div><div class="line">        <span class="comment">//计算每个item的位置，大小</span></div><div class="line">        <span class="built_in">CGFloat</span> itemX = index * (width+<span class="keyword">self</span>.minimumLineSpacing) + <span class="keyword">self</span>.sectionInset.left;</div><div class="line">        <span class="built_in">CGFloat</span> itemY = columnHeight[index];</div><div class="line">        <span class="built_in">CGFloat</span> itemHeight = [<span class="keyword">self</span> makeNum];</div><div class="line">        </div><div class="line">        attributes.frame = <span class="built_in">CGRectMake</span>(itemX, itemY, width, itemHeight);</div><div class="line">        </div><div class="line">        [<span class="keyword">self</span>.attributesArray addObject:attributes];</div><div class="line">        </div><div class="line">        columnHeight[index] += itemHeight+<span class="keyword">self</span>.minimumInteritemSpacing;</div><div class="line">        columnNum[index] ++;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//计算最高列</span></div><div class="line">    <span class="keyword">int</span> maxIndex = [<span class="keyword">self</span> computerMaxHeightWithArray:columnHeight];</div><div class="line">    _maxHeight = columnHeight[maxIndex];</div><div class="line">    <span class="comment">//计算 item 的大小平均值，这样可以大致确定 collectionView 的内容视图尺寸，但不是太准确</span></div><div class="line">    <span class="built_in">CGFloat</span> aveHeight = (columnHeight[maxIndex] - <span class="keyword">self</span>.sectionInset.top - columnNum[maxIndex]*<span class="keyword">self</span>.minimumLineSpacing)/columnNum[maxIndex];</div><div class="line">    <span class="keyword">self</span>.itemSize = <span class="built_in">CGSizeMake</span>(width, aveHeight);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="2-在-layoutAttributesForElementsInRect-方法中-return-所有-item-的-attributes-数组"><a href="#2-在-layoutAttributesForElementsInRect-方法中-return-所有-item-的-attributes-数组" class="headerlink" title="2.在 layoutAttributesForElementsInRect: 方法中 return 所有 item 的 attributes 数组"></a>2.在 <code>layoutAttributesForElementsInRect:</code> 方法中 return 所有 item 的 attributes 数组</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回collectionView视图中所有视图的属性(UICollectionViewLayoutAttributes)数组</span></div><div class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">UICollectionViewLayoutAttributes</span> *&gt; *)layoutAttributesForElementsInRect:(<span class="built_in">CGRect</span>)rect&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.attributesArray;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-写完上一步，这个垂直瀑布流的布局类基本写完了，但是我们发现内容尺寸还是不太对，之前这个内容尺寸是布局类根据自身的属性-itemSize-来计算的，而-itemSize-取的是平均值，这样算出的内容尺寸会有些偏差，我们再重写一下-collectionViewContentSize-方法"><a href="#3-写完上一步，这个垂直瀑布流的布局类基本写完了，但是我们发现内容尺寸还是不太对，之前这个内容尺寸是布局类根据自身的属性-itemSize-来计算的，而-itemSize-取的是平均值，这样算出的内容尺寸会有些偏差，我们再重写一下-collectionViewContentSize-方法" class="headerlink" title="3.写完上一步，这个垂直瀑布流的布局类基本写完了，但是我们发现内容尺寸还是不太对，之前这个内容尺寸是布局类根据自身的属性 itemSize 来计算的，而 itemSize 取的是平均值，这样算出的内容尺寸会有些偏差，我们再重写一下 collectionViewContentSize 方法"></a>3.写完上一步，这个垂直瀑布流的布局类基本写完了，但是我们发现内容尺寸还是不太对，之前这个内容尺寸是布局类根据自身的属性 itemSize 来计算的，而 itemSize 取的是平均值，这样算出的内容尺寸会有些偏差，我们再重写一下 <code>collectionViewContentSize</code> 方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//内容尺寸</span></div><div class="line"><span class="comment">//取最高列的高度作为内容尺寸的高度</span></div><div class="line">- (<span class="built_in">CGSize</span>)collectionViewContentSize&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="built_in">CGSizeMake</span>(<span class="keyword">self</span>.collectionView.bounds.size.width, _maxHeight);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="垂直的写完了，再来看看水平的是怎么实现的"><a href="#垂直的写完了，再来看看水平的是怎么实现的" class="headerlink" title="垂直的写完了，再来看看水平的是怎么实现的"></a>垂直的写完了，再来看看水平的是怎么实现的</h3><h4 id="1-同样的首先去复写-prepareLayout-方法，在此方法里面计算每个-item-的-attributes"><a href="#1-同样的首先去复写-prepareLayout-方法，在此方法里面计算每个-item-的-attributes" class="headerlink" title="1.同样的首先去复写 prepareLayout 方法，在此方法里面计算每个 item 的 attributes"></a>1.同样的首先去复写 <code>prepareLayout</code> 方法，在此方法里面计算每个 item 的 attributes</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepareLayout&#123;</div><div class="line">    [<span class="keyword">self</span> computeAttributes];</div><div class="line">&#125;</div><div class="line"><span class="comment">//计算每个单元格的属性</span></div><div class="line">- (<span class="keyword">void</span>)computeAttributes&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//存贮每行个数</span></div><div class="line">    <span class="built_in">NSMutableArray</span> *lineNum = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">    [lineNum insertObject:@<span class="number">0</span> atIndex:<span class="number">0</span>];</div><div class="line">    <span class="comment">//储存每行宽度</span></div><div class="line">    <span class="built_in">NSMutableArray</span> *lineWidth = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">    [lineWidth insertObject:@<span class="number">10.0</span> atIndex:<span class="number">0</span>];</div><div class="line">    <span class="comment">//记录当前高度</span></div><div class="line">    <span class="built_in">CGFloat</span> verticalHeight = <span class="number">10</span>;</div><div class="line">    <span class="comment">//当前添加的行号</span></div><div class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="keyword">self</span>.dataList.count; k ++) &#123;</div><div class="line">        <span class="built_in">NSArray</span> *array = <span class="keyword">self</span>.dataList[k];</div><div class="line">        </div><div class="line">        <span class="comment">//添加一个组头</span></div><div class="line">        <span class="built_in">UICollectionViewLayoutAttributes</span> *headerAttributes = [<span class="built_in">UICollectionViewLayoutAttributes</span> layoutAttributesForSupplementaryViewOfKind:<span class="built_in">UICollectionElementKindSectionHeader</span> withIndexPath:[<span class="built_in">NSIndexPath</span> indexPathForItem:<span class="number">0</span> inSection:k]];</div><div class="line">        headerAttributes.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, verticalHeight + k*<span class="number">50</span>, kScreenWidth, <span class="number">50</span>);</div><div class="line">        [<span class="keyword">self</span>.attributesArray addObject:headerAttributes];</div><div class="line">        <span class="comment">//相当于添加了一行</span></div><div class="line">        [lineNum addObject:@<span class="number">1</span>];</div><div class="line">        [lineWidth addObject:@(kScreenWidth)];</div><div class="line">        <span class="comment">//添加组头，不需要计算组头的高度，单元格会自动适配到组头下面</span></div><div class="line">        verticalHeight += <span class="number">10</span>;</div><div class="line">        index ++;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.count; i ++) &#123;</div><div class="line">            <span class="built_in">UICollectionViewLayoutAttributes</span> *attributes = [<span class="built_in">UICollectionViewLayoutAttributes</span> layoutAttributesForCellWithIndexPath:[<span class="built_in">NSIndexPath</span> indexPathForItem:i inSection:k]];</div><div class="line">            <span class="comment">//计算宽度</span></div><div class="line">            <span class="built_in">CGFloat</span> width = [<span class="keyword">self</span> computerWidthWithString:array[i]];</div><div class="line">            <span class="comment">//计算位置</span></div><div class="line">            <span class="built_in">CGFloat</span> X;</div><div class="line">            <span class="built_in">CGFloat</span> Y;</div><div class="line">            <span class="built_in">CGFloat</span> indexWidth = [lineWidth[index] floatValue];  <span class="comment">//当前行宽</span></div><div class="line">            <span class="keyword">if</span> ((indexWidth+width+<span class="number">10</span>) &lt;= <span class="keyword">self</span>.collectionView.bounds.size.width) &#123;</div><div class="line">                <span class="comment">//如果添加一个单元格，此行宽度还小于控件宽度，那就添加到此行</span></div><div class="line">                X = [lineWidth[index] floatValue];</div><div class="line">                Y = verticalHeight;</div><div class="line">                lineNum[index] = @([lineNum[index] intValue]+<span class="number">1</span>);</div><div class="line">                lineWidth[index] = @([lineWidth[index] floatValue]+width+<span class="number">10</span>);</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="comment">//如果添加一个单元格，此行宽度大于控件宽度，那就另起一行</span></div><div class="line">                index++;</div><div class="line">                verticalHeight += <span class="number">50</span>;</div><div class="line">                Y = verticalHeight;</div><div class="line">                X = <span class="number">10.0</span>;</div><div class="line">                [lineNum addObject:@(<span class="number">1</span>)];</div><div class="line">                [lineWidth addObject:@(width+<span class="number">10</span>+<span class="number">10</span>)];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            attributes.frame = <span class="built_in">CGRectMake</span>(X, Y, width, <span class="number">40</span>);</div><div class="line">            [<span class="keyword">self</span>.attributesArray addObject:attributes];</div><div class="line">            </div><div class="line">            <span class="comment">//设置平均item属性</span></div><div class="line">            <span class="keyword">int</span> maxIndex = [<span class="keyword">self</span> computerMAXlineWithArray:lineWidth];</div><div class="line">            <span class="built_in">CGFloat</span> aveWidth = ([lineWidth[maxIndex] floatValue]-[lineNum[maxIndex] intValue]*<span class="number">10</span><span class="number">-10</span>)/[lineNum[maxIndex] intValue];</div><div class="line">            <span class="keyword">self</span>.itemSize = <span class="built_in">CGSizeMake</span>(aveWidth, <span class="number">40</span>);</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里着重介绍这个计算方法<br>跟垂直瀑布流不同的是，水平瀑布流的计算方法是不断的将 item 往一行中放，直到这一行的宽度 + 新 item 的宽度已经超出了控件（collectionView）的宽度，那我们就另起一行。还要考虑的一个问题是，我们在这个水平瀑布流中添加了头视图。<br>头视图的 attributes 也是要添加入 collectionView 的 attributes 数组中的，这个头视图的位置我直接当做另起了一行，但是它的类型有所不同，它的类型是一个 <code>UICollectionElementKindSectionHeader</code> 。这个地方有一个坑，我调试了好久才调试好，单元格的位置是相对于这个头视图来定位的，也就是说，如果我们计算其他 item 的位置时加上了这个头视图的高度，那么实际效果就是这个 item 与头视图之间会多出一个头视图的距离。</p>
<h4 id="2-最后还是返回它的-attributes-数组"><a href="#2-最后还是返回它的-attributes-数组" class="headerlink" title="2.最后还是返回它的 attributes 数组"></a>2.最后还是返回它的 attributes 数组</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回属性数组</span></div><div class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">UICollectionViewLayoutAttributes</span> *&gt; *)layoutAttributesForElementsInRect:(<span class="built_in">CGRect</span>)rect&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.attributesArray;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后依旧放上我们可爱的 demo</p>
<p><a href="https://github.com/li1024316925/Waterfall" target="_blank" rel="external">demo 点这里！点这里！</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本篇文章主要介绍瀑布流的实现原理，demo以原理为主，随便写了写，封装性不好，如果拿去直接用需要修改的地方是比较多的。所以此文章仅供学习，想直接用的小伙伴需要多费些功夫了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;话不多说，先看看效果图&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用 FFmpeg 做一个简单的 RTMP 推流</title>
    <link href="http://yoursite.com/2016/12/29/%E4%BD%BF%E7%94%A8-FFmpeg-%E5%81%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-RTMP-%E6%8E%A8%E6%B5%81/"/>
    <id>http://yoursite.com/2016/12/29/使用-FFmpeg-做一个简单的-RTMP-推流/</id>
    <published>2016-12-29T13:37:33.000Z</published>
    <updated>2017-02-27T08:15:07.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>站在大牛肩膀上编程—— i_have_an_Apple😂</p>
</blockquote>
<p>上面那句话是我扯淡呢，大家乐一乐就好</p>
<p>在本文的开始，我们要感谢真正的大牛，雷神。<br><a href="http://blog.csdn.net/leixiaohua1020/article/details/47072519" target="_blank" rel="external">这是雷神的博客</a></p>
<p>此篇文章，主要是对大牛 demo 的详细注释，本人最近在研究 FFmpeg 也有很多不懂的地方，欢迎各位小伙伴留言一起讨论。</p>
<p>FFmpeg 的编译与集成这里不再赘述，这里直接进入正题</p>
<h3 id="首先定义一些相关的结构体，并将它们初始化"><a href="#首先定义一些相关的结构体，并将它们初始化" class="headerlink" title="首先定义一些相关的结构体，并将它们初始化"></a>首先定义一些相关的结构体，并将它们初始化</h3><p>这边我提供了一个推流地址，这个地址是我自己搭建的 SRS(simple-rtmp-server) 服务器地址，因为服务器是收费的，我也不能一直开着，各位如果想测试 demo ，大家可以自己搭建一个虚拟机，同样可以作为服务器。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> input_str_full[<span class="number">500</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">    <span class="keyword">char</span> output_str_full[<span class="number">500</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">    </div><div class="line">    <span class="comment">//文件地址</span></div><div class="line">    <span class="built_in">NSString</span> *input_str = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"war3end.mp4"</span> ofType:<span class="literal">nil</span>];</div><div class="line">    <span class="comment">//推流地址</span></div><div class="line">    <span class="built_in">NSString</span> *output_str = <span class="string">@"rtmp://106.75.92.197/live/test"</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//将地址写入到创建好的容器</span></div><div class="line">    sprintf(input_str_full, <span class="string">"%s"</span>,[input_str UTF8String]);</div><div class="line">    sprintf(output_str_full, <span class="string">"%s"</span>,[output_str UTF8String]);</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"input_str_full:%s"</span>,input_str_full);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"output_str_full:%s"</span>,output_str_full);</div><div class="line">    </div><div class="line">    <span class="comment">//初始化</span></div><div class="line">    <span class="built_in">AVOutputFormat</span> *ofmt = <span class="literal">NULL</span>;</div><div class="line">    <span class="comment">//输入format和输出format</span></div><div class="line">    <span class="built_in">AVFormatContext</span> *ifmt_ctx = <span class="literal">NULL</span>, *ofmt_ctx = <span class="literal">NULL</span>;</div><div class="line">    <span class="built_in">AVPacket</span> pkt;  <span class="comment">//存储解码前数据</span></div><div class="line">    <span class="keyword">char</span> in_filename[<span class="number">500</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">    <span class="keyword">char</span> out_filename[<span class="number">500</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">    <span class="keyword">int</span> ret, i;</div><div class="line">    <span class="keyword">int</span> videoindex = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">int</span> frame_index = <span class="number">0</span>;</div><div class="line">    int64_t start_time = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//strcpy(a,b) 把 b 中的内容复制到 a 中</span></div><div class="line">    strcpy(in_filename, input_str_full);</div><div class="line">    strcpy(out_filename, output_str_full);</div><div class="line">    </div><div class="line">    <span class="comment">//注册</span></div><div class="line">    av_register_all();</div><div class="line">    <span class="comment">//网络初始化</span></div><div class="line">    avformat_network_init();</div></pre></td></tr></table></figure></p>
<h3 id="读取本地的-MP4-文件，并打开推流地址"><a href="#读取本地的-MP4-文件，并打开推流地址" class="headerlink" title="读取本地的 MP4 文件，并打开推流地址"></a>读取本地的 MP4 文件，并打开推流地址</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">//Input</span></div><div class="line">    <span class="comment">//打开文件，存储到输入上下文中</span></div><div class="line">    <span class="keyword">if</span> ((ret = avformat_open_input(&amp;ifmt_ctx, in_filename, <span class="number">0</span>, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</div><div class="line">        printf(<span class="string">"未能打开文件\n"</span>);</div><div class="line">        goto end;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//查找输入流数据</span></div><div class="line">    <span class="keyword">if</span> ((ret = avformat_find_stream_info(ifmt_ctx, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</div><div class="line">        printf(<span class="string">"未能找到输入流数据\n"</span>);</div><div class="line">        goto end;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//输入流数据的数量循环</span></div><div class="line">    <span class="function"><span class="title">for</span> (i = 0; i &lt; ifmt_ctx-&gt;</span>nb_streams; i ++) &#123;</div><div class="line">        <span class="function"><span class="title">if</span> (ifmt_ctx-&gt;</span><span class="function"><span class="title">streams</span>[i]-&gt;</span><span class="function"><span class="title">codec</span>-&gt;</span>codec_type == AVMEDIA_TYPE_VIDEO) &#123;</div><div class="line">            videoindex = i;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//检查一些设置的参数有无问题</span></div><div class="line">    av_dump_format(ifmt_ctx, <span class="number">0</span>, in_filename, <span class="number">0</span>);</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">//Output</span></div><div class="line">    <span class="comment">//初始化输出上下文</span></div><div class="line">    avformat_alloc_output_context2(&amp;ofmt_ctx, NULL, <span class="string">"flv"</span>, out_filename); <span class="comment">//RTMP</span></div><div class="line"><span class="comment">//    avformat_alloc_output_context2(&amp;ofmt_ctx, NULL, "mpegts", out_filename); //UDP</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!ofmt_ctx) &#123;</div><div class="line">        printf(<span class="string">"输出上下文未能初始化成功\n"</span>);</div><div class="line">        ret = AVERROR_UNKNOWN;</div><div class="line">        goto end;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//从输出上下文中拿到存储输出信息的结构体</span></div><div class="line">    <span class="function"><span class="title">ofmt</span> = ofmt_ctx-&gt;</span>oformat;</div><div class="line">    </div><div class="line">    <span class="function"><span class="title">for</span> (i = 0; i &lt; ifmt_ctx-&gt;</span>nb_streams; i ++) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//获取输入视频流</span></div><div class="line">        AVS<span class="function"><span class="title">tream</span> *in_stream = ifmt_ctx-&gt;</span>streams[i];</div><div class="line">        <span class="comment">//为输出上下文添加音视频流（初始化一个音视频流容器）</span></div><div class="line">        AVS<span class="function"><span class="title">tream</span> *out_stream = avformat_new_stream(ofmt_ctx, in_stream-&gt;</span><span class="function"><span class="title">codec</span>-&gt;</span>codec);</div><div class="line">        <span class="keyword">if</span> (!out_stream) &#123;</div><div class="line">            printf(<span class="string">"未能成功添加音视频流\n"</span>);</div><div class="line">            ret = AVERROR_UNKNOWN;</div><div class="line">            goto end;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//将输入编解码器上下文信息 copy 给输出编解码器上下文</span></div><div class="line">        <span class="function"><span class="title">ret</span> = avcodec_copy_context(out_stream-&gt;</span><span class="function"><span class="title">codec</span>, in_stream-&gt;</span>codec);</div><div class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</div><div class="line">            printf(<span class="string">"copy 编解码器上下文失败\n"</span>);</div><div class="line">            goto end;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//这里没看懂....</span></div><div class="line">        <span class="function"><span class="title">out_stream</span>-&gt;</span><span class="function"><span class="title">codec</span>-&gt;</span>codec_tag = <span class="number">0</span>;</div><div class="line">        <span class="function"><span class="title">if</span> (ofmt_ctx-&gt;</span><span class="function"><span class="title">oformat</span>-&gt;</span>flags &amp; AVFMT_GLOBALHEADER) &#123;</div><div class="line">            <span class="function"><span class="title">out_stream</span>-&gt;</span><span class="function"><span class="title">codec</span>-&gt;</span><span class="function"><span class="title">flags</span> = out_stream-&gt;</span><span class="function"><span class="title">codec</span>-&gt;</span>flags | CODEC_FLAG_GLOBAL_HEADER;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//检查参数设置有无问题</span></div><div class="line">    av_dump_format(ofmt_ctx, <span class="number">0</span>, out_filename, <span class="number">1</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//打开输出地址（推流地址）</span></div><div class="line">    <span class="function"><span class="title">if</span> (!(ofmt-&gt;</span>flags &amp; AVFMT_NOFILE)) &#123;</div><div class="line">        <span class="function"><span class="title">ret</span> = avio_open(&amp;ofmt_ctx-&gt;</span>pb, out_filename, AVIO_FLAG_WRITE);</div><div class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</div><div class="line">            printf(<span class="string">"无法打开地址 '%s'"</span>,out_filename);</div><div class="line">            goto end;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="接下来就是最重要的推流了"><a href="#接下来就是最重要的推流了" class="headerlink" title="接下来就是最重要的推流了"></a>接下来就是最重要的推流了</h3><p>前面我们已经通过服务器地址打开了服务器，以我的理解推流实际上就是往服务器写入文件，然后剩下的事情比如转发等等就是服务器的工作了。<br>下面的代码中，计算<br>PTS（Presentation Time Stamp）显示播放时间戳<br>DTS（Decoding Time Stamp）解码时间戳<br>比较重要<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">//写视频文件头</span></div><div class="line">    ret = avformat_write_header(ofmt_ctx, NULL);</div><div class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</div><div class="line">        printf(<span class="string">"在 URL 所在的文件写视频头出错\n"</span>);</div><div class="line">        goto end;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//取得时间</span></div><div class="line">    start_time = av_gettime();</div><div class="line">    </div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">//输入输出视频流</span></div><div class="line">        AVStream *in_stream, *out_stream;</div><div class="line">        <span class="comment">//获取解码前数据</span></div><div class="line">        ret = av_read_frame(ifmt_ctx, &amp;pkt);</div><div class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">/*</span></div><div class="line">         PTS（Presentation Time Stamp）显示播放时间</div><div class="line">         DTS（Decoding Time Stamp）解码时间</div><div class="line">         */</div><div class="line">        <span class="comment">//没有显示时间（比如未解码的 H.264 ）</span></div><div class="line">        <span class="keyword">if</span> (pkt.pts == AV_NOPTS_VALUE) &#123;</div><div class="line">            <span class="comment">//AVRational time_base：时基。通过该值可以把PTS，DTS转化为真正的时间。</span></div><div class="line">            AVR<span class="function"><span class="title">ational</span> time_base1 = ifmt_ctx-&gt;</span><span class="function"><span class="title">streams</span>[videoindex]-&gt;</span>time_base;</div><div class="line">            </div><div class="line">            <span class="comment">//计算两帧之间的时间</span></div><div class="line">            <span class="comment">/*</span></div><div class="line">             r_frame_rate 基流帧速率  （不是太懂）</div><div class="line">             av_q2d 转化为double类型</div><div class="line">             */</div><div class="line">            <span class="function"><span class="title">int64_t</span> calc_duration = (double)AV_TIME_BASE/av_q2d(ifmt_ctx-&gt;</span><span class="function"><span class="title">streams</span>[videoindex]-&gt;</span>r_frame_rate);</div><div class="line">            </div><div class="line">            <span class="comment">//配置参数</span></div><div class="line">            pkt.pts = (double)(frame_index*calc_duration)/(double)(av_q2d(time_base1)*AV_TIME_BASE);</div><div class="line">            pkt.dts = pkt.pts;</div><div class="line">            pkt.duration = (double)calc_duration/(double)(av_q2d(time_base1)*AV_TIME_BASE);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//延时</span></div><div class="line">        <span class="keyword">if</span> (pkt.stream_index == videoindex) &#123;</div><div class="line">            AVR<span class="function"><span class="title">ational</span> time_base = ifmt_ctx-&gt;</span><span class="function"><span class="title">streams</span>[videoindex]-&gt;</span>time_base;</div><div class="line">            AVRational time_base_q = &#123;<span class="number">1</span>,AV_TIME_BASE&#125;;</div><div class="line">            <span class="comment">//计算视频播放时间</span></div><div class="line">            int64_t pts_time = av_rescale_q(pkt.dts, time_base, time_base_q);</div><div class="line">            <span class="comment">//计算实际视频的播放时间</span></div><div class="line">            int64_t now_time = av_gettime() - start_time;</div><div class="line">            <span class="keyword">if</span> (pts_time &gt; now_time) &#123;</div><div class="line">                <span class="comment">//睡眠一段时间（目的是让当前视频记录的播放时间与实际时间同步）</span></div><div class="line">                av_usleep((unsigned int)(pts_time - now_time));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="title">in_stream</span> = ifmt_ctx-&gt;</span>streams[pkt.stream_index];</div><div class="line">        <span class="function"><span class="title">out_stream</span> = ofmt_ctx-&gt;</span>streams[pkt.stream_index];</div><div class="line"></div><div class="line"><span class="comment">//计算延时后，重新指定时间戳</span></div><div class="line">        <span class="function"><span class="title">pkt</span>.pts = av_rescale_q_rnd(pkt.pts, in_stream-&gt;</span><span class="function"><span class="title">time_base</span>, out_stream-&gt;</span>time_base, (AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX));</div><div class="line">        <span class="function"><span class="title">pkt</span>.dts = av_rescale_q_rnd(pkt.dts, in_stream-&gt;</span><span class="function"><span class="title">time_base</span>, out_stream-&gt;</span>time_base, (AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX));</div><div class="line">        <span class="function"><span class="title">pkt</span>.duration = (int)av_rescale_q(pkt.duration, in_stream-&gt;</span><span class="function"><span class="title">time_base</span>, out_stream-&gt;</span>time_base);</div><div class="line">        <span class="comment">//字节流的位置，-1 表示不知道字节流位置</span></div><div class="line">        pkt.pos = -<span class="number">1</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (pkt.stream_index == videoindex) &#123;</div><div class="line">            printf(<span class="string">"Send %8d video frames to output URL\n"</span>,frame_index);</div><div class="line">            frame_index++;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//向输出上下文发送（向地址推送）</span></div><div class="line">        ret = av_interleaved_write_frame(ofmt_ctx, &amp;pkt);</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</div><div class="line">            printf(<span class="string">"发送数据包出错\n"</span>);</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//释放</span></div><div class="line">        av_free_packet(&amp;pkt);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//写文件尾</span></div><div class="line">    av_write_trailer(ofmt_ctx);</div></pre></td></tr></table></figure></p>
<h3 id="最后是一个-end-节点，上述过程中有多个跳转-end-节点，在出错时结束程序并释放各个结构体"><a href="#最后是一个-end-节点，上述过程中有多个跳转-end-节点，在出错时结束程序并释放各个结构体" class="headerlink" title="最后是一个 end 节点，上述过程中有多个跳转 end 节点，在出错时结束程序并释放各个结构体"></a>最后是一个 end 节点，上述过程中有多个跳转 end 节点，在出错时结束程序并释放各个结构体</h3><blockquote>
<p>不推荐大家使用 <code>goto</code> 语句，这里逻辑比较简单，且代码块太长，所以才使用了一个 <code>goto</code> 语句</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//end 节点</span></div><div class="line">end:</div><div class="line">    </div><div class="line">    <span class="comment">//关闭输入上下文</span></div><div class="line">    avformat_close_input(&amp;ifmt_ctx);</div><div class="line">    <span class="comment">//关闭输出上下文</span></div><div class="line">    <span class="keyword">if</span> (ofmt_ctx &amp;&amp; !(ofmt-&gt;flags &amp; AVFMT_NOFILE)) &#123;</div><div class="line">        avio_close(ofmt_ctx-&gt;pb);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//释放输出上下文</span></div><div class="line">    avformat_free_context(ofmt_ctx);</div><div class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; ret != AVERROR_EOF) &#123;</div><div class="line">        printf(<span class="string">"发生错误\n"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span>;</div></pre></td></tr></table></figure>
<p>按照惯例，在这最后的最后，放上 demo 源码<br><a href="https://github.com/li1024316925/FFmpeg-RTMP-PushStream" target="_blank" rel="external">点这里点这里点这里点这里</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;站在大牛肩膀上编程—— i_have_an_Apple😂&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面那句话是我扯淡呢，大家乐一乐就好&lt;/p&gt;
&lt;p&gt;在本文的开始，我们要感谢真正的大牛，雷神。&lt;br&gt;&lt;a href=&quot;http://blog.c
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>重写 View 的 Touch 方法，实现一个酷炫的九宫格图片</title>
    <link href="http://yoursite.com/2016/12/23/%E9%87%8D%E5%86%99-View-%E7%9A%84-Touch-%E6%96%B9%E6%B3%95%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%85%B7%E7%82%AB%E7%9A%84%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2016/12/23/重写-View-的-Touch-方法，实现一个酷炫的九宫格图片/</id>
    <published>2016-12-23T03:30:21.000Z</published>
    <updated>2017-02-27T08:02:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前几天翻看代码库，发现一个之前写过的一个有意思的小玩意，共享给大家😄</strong></p>
<p><strong>废话不多说，上图，先看看效果</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1393645-f29e68c106c78c5f.gif?imageMogr2/auto-orient/strip" alt="photosView.gif"></p>
<p>怎么样，是不是还蛮有意思呢？</p>
<p>实现起来非常简单，我们只需要重写几个 View 的 touch 方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//触摸开始</span></div><div class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//获取触摸点</span></div><div class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</div><div class="line">    <span class="built_in">CGPoint</span> point = [touch locationInView:<span class="keyword">self</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//当前点击到的图片的下标小于图片数组的元素个数</span></div><div class="line">    _selectIndex = [<span class="keyword">self</span> itemIndexWithPoint:point];</div><div class="line">    <span class="keyword">if</span> (_selectIndex &lt; <span class="keyword">self</span>.itemArray.count) &#123;</div><div class="line">        <span class="built_in">UIImageView</span> *item = <span class="keyword">self</span>.itemArray[_selectIndex];</div><div class="line">        <span class="comment">//拿到最上层</span></div><div class="line">        [<span class="keyword">self</span> bringSubviewToFront:item];</div><div class="line">        <span class="comment">//动画效果</span></div><div class="line">        [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.3</span> animations:^&#123;</div><div class="line">            <span class="comment">//改变当前选中图片视图的大小和位置</span></div><div class="line">            item.center = point;</div><div class="line">            item.transform = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">1.2</span>, <span class="number">1.2</span>);</div><div class="line">            item.alpha = <span class="number">0.8</span>;</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在触摸一开始，我们先判定当前触摸的点是在哪一张图片上，获得这张图片的下标，并设置为选中下标，然后改变当前图片的位置（中心移动到触摸点）和大小（放大效果）。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//触摸移动</span></div><div class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//获取触摸点</span></div><div class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</div><div class="line">    <span class="built_in">CGPoint</span> point = [touch locationInView:<span class="keyword">self</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//获取当前触摸点位置下标</span></div><div class="line">    <span class="built_in">NSInteger</span> index = [<span class="keyword">self</span> itemIndexWithPoint:point];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (_selectIndex &lt; <span class="keyword">self</span>.itemArray.count) &#123;</div><div class="line">        <span class="built_in">UIImageView</span> *item = <span class="keyword">self</span>.itemArray[_selectIndex];</div><div class="line">        item.center = point;</div><div class="line">        <span class="keyword">if</span> (index &lt; <span class="keyword">self</span>.itemArray.count &amp;&amp; index != _selectIndex) &#123;</div><div class="line">            <span class="comment">//当前点位置所属下标与选中下标不同</span></div><div class="line">            <span class="comment">//将两个图片分别在数据源数组和子视图数组中移除</span></div><div class="line">            <span class="built_in">UIImage</span> *image = _dataList[_selectIndex];</div><div class="line">            [_dataList removeObjectAtIndex:_selectIndex];</div><div class="line">            [<span class="keyword">self</span>.itemArray removeObjectAtIndex:_selectIndex];</div><div class="line">            <span class="comment">//重新插入到指定位置</span></div><div class="line">            [_dataList insertObject:image atIndex:index];</div><div class="line">            [<span class="keyword">self</span>.itemArray insertObject:item atIndex:index];</div><div class="line">            <span class="comment">//重新记录选中下标</span></div><div class="line">            _selectIndex = index;</div><div class="line">            <span class="comment">//重新布局</span></div><div class="line">            [<span class="keyword">self</span> restartMakeItemFram];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在触摸移动方法中再次判定当前触摸点所在的图片下标，然后比较选中下标与当前下标，如果不相同，就交换两张图片的位置。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//触摸结束</span></div><div class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (_selectIndex &lt; _itemArray.count) &#123;</div><div class="line">        <span class="built_in">UIImageView</span> *item = _itemArray[_selectIndex];</div><div class="line">        </div><div class="line">        <span class="comment">//还原操作</span></div><div class="line">        [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.3</span> animations:^&#123;</div><div class="line">            item.transform = <span class="built_in">CGAffineTransformIdentity</span>;</div><div class="line">            item.alpha = <span class="number">1</span>;</div><div class="line">            item.frame = [<span class="keyword">self</span> makeFrameWithIndex:(<span class="keyword">int</span>)_selectIndex];</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，在触摸结束方法中还原选中图片的大小，重新计算它的位置</p>
<p>是不是很简单呢？下面附上 Demo 的地址<br><a href="https://github.com/li1024316925/PhotosView" target="_blank" rel="external">Demo点这里~点这里~</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前几天翻看代码库，发现一个之前写过的一个有意思的小玩意，共享给大家😄&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;废话不多说，上图，先看看效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>FFmpeg解码本地H.264</title>
    <link href="http://yoursite.com/2016/12/15/FFmpeg%E8%A7%A3%E7%A0%81%E6%9C%AC%E5%9C%B0H-264/"/>
    <id>http://yoursite.com/2016/12/15/FFmpeg解码本地H-264/</id>
    <published>2016-12-15T09:28:46.000Z</published>
    <updated>2017-02-27T07:59:47.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>最近学习 FFmpeg，自己写了一个小 Demo 解码一个 H.264 裸流数据<br>FFmpeg 的编译导入等工作我们不再赘述，下面直接进入正题</p>
</blockquote>
<p>导入库文件<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavcodec/avcodec.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libswscale/swscale.h&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>声明一些我们需要用到的全局变量<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LLQH264Decoder</span>()&lt;<span class="title">UIAlertViewDelegate</span>&gt;</span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">AVFormatContext</span> *pFormatCtx;  <span class="comment">//解码上下文，贯穿整个解码过程</span></div><div class="line">    <span class="keyword">int</span> i,videoIndex;</div><div class="line">    <span class="built_in">AVCodecContext</span> *pCodecCtx;  <span class="comment">//解码器上下文，存储解码器、解码信息等</span></div><div class="line">    <span class="built_in">AVCodec</span> *pCodec;  <span class="comment">//解码器</span></div><div class="line">    <span class="built_in">AVFrame</span> *pFrame, *pFrameYUV;  <span class="comment">//存储每一帧的原始数据</span></div><div class="line">    uint8_t *out_Buffer;</div><div class="line">    <span class="built_in">AVPacket</span> *packet;  <span class="comment">//存储每一帧的解码后数据</span></div><div class="line">    <span class="keyword">int</span> ret,got_picture;</div><div class="line">    <span class="keyword">struct</span> SwsContext *img_convert_ctx;</div><div class="line">    <span class="keyword">int</span> frame_cnt;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>准备工作已经做完了，下面开始重点</p>
<h1 id="解码部分"><a href="#解码部分" class="headerlink" title="解码部分"></a>解码部分</h1><p>我们通过传入一个 H.264 文件的路径，来读取这个文件<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line">- (void)setupFFMPEGwithPath:(NSString *)path&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//注册编解码器</span></div><div class="line">    av_register_all();</div><div class="line">    <span class="comment">//</span></div><div class="line">    avformat_network_init();</div><div class="line">    <span class="comment">//初始化 贯穿整个解码的解码上下文</span></div><div class="line">    pFormatCtx = avformat_alloc_context();</div><div class="line">    </div><div class="line">    <span class="comment">//打开文件  返回0表示成功，所有数据存储在formatCtx中</span></div><div class="line">    <span class="keyword">if</span> (avformat_open_input(&amp;pFormatCtx, path.UTF8String, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>) != <span class="number">0</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> showAlerViewTitle:@<span class="string">"不能打开流文件"</span>];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//读取数据包获取流媒体文件的信息</span></div><div class="line">    <span class="keyword">if</span> (avformat_find_stream_info(pFormatCtx, <span class="keyword">NULL</span>) &lt; <span class="number">0</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> showAlerViewTitle:@<span class="string">"不能读取到流信息"</span>];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    videoIndex = <span class="number">-1</span>;</div><div class="line">    <span class="comment">//查找视频流</span></div><div class="line">    <span class="comment">//nb_streams视音频流的个数</span></div><div class="line">    <span class="comment">//streams视音频流</span></div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pFormatCtx-&gt;nb_streams; i ++) &#123;</div><div class="line">        <span class="comment">//直至查找到视频流</span></div><div class="line">        <span class="keyword">if</span> (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123;</div><div class="line">            videoIndex = i;</div><div class="line">            NSLog(@<span class="string">"videoIndex==%d"</span>,videoIndex);  <span class="comment">//视频流的下标</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (videoIndex == <span class="number">-1</span>) &#123;</div><div class="line">            [<span class="keyword">self</span> showAlerViewTitle:@<span class="string">"没有视频流"</span>];</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//取出查找到的视频流的解码器信息</span></div><div class="line">    pCodecCtx = pFormatCtx-&gt;streams[videoIndex]-&gt;codec;</div><div class="line">    </div><div class="line">    <span class="comment">//初始化解码器</span></div><div class="line">    pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (pCodec == <span class="keyword">NULL</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> showAlerViewTitle:@<span class="string">"找不到解码器"</span>];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//打开解码器</span></div><div class="line">    <span class="keyword">if</span> (avcodec_open2(pCodecCtx, pCodec, <span class="keyword">NULL</span>) &lt; <span class="number">0</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> showAlerViewTitle:@<span class="string">"不能打开解码器"</span>];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//初始化frame，packet</span></div><div class="line">    <span class="comment">//AVPacket里面的是H.264码流数据</span></div><div class="line">    <span class="comment">//AVFrame里面装的是YUV数据。YUV是经过decoder解码AVPacket的数据</span></div><div class="line">    pFrame = av_frame_alloc();</div><div class="line">    packet = (AVPacket *)malloc(sizeof(AVPacket));</div><div class="line">    </div><div class="line">    <span class="comment">//打印一大堆时间、比特率、流、容器、编解码器和时间等</span></div><div class="line">    av_dump_format(pFormatCtx, <span class="number">0</span>, path.UTF8String, <span class="number">0</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//为解码为image做准备</span></div><div class="line">    img_convert_ctx = sws_getContext(pCodecCtx-&gt;width, pCodecCtx-&gt;height, pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx-&gt;height, PIX_FMT_YUV420P, SWS_BICUBIC, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</div><div class="line">    frame_cnt = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//开辟线程操作</span></div><div class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">        <span class="comment">//从formatCtx中读取，一帧一帧的读取，循环一次，就读取一帧</span></div><div class="line">        <span class="keyword">while</span> (av_read_frame(pFormatCtx, packet) &gt;= <span class="number">0</span>) &#123;</div><div class="line">            NSLog(@<span class="string">"packet-&gt;data==%d"</span>,packet-&gt;size);</div><div class="line">            <span class="keyword">if</span> (packet-&gt;stream_index == videoIndex) &#123;</div><div class="line">                <span class="comment">//根据获取到的packet生成pFrame(AVFrame)实际上就是解码</span></div><div class="line">                <span class="comment">//如果没有需要解码的帧则got_picture就会为0</span></div><div class="line">                ret = avcodec_decode_video2(pCodecCtx, pFrame, &amp;got_picture, packet);</div><div class="line">                <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</div><div class="line">                    [<span class="keyword">self</span> showAlerViewTitle:@<span class="string">"解码错误"</span>];</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (got_picture) &#123;</div><div class="line">                    </div><div class="line">                    <span class="comment">//这里是播放部分，有两种播放方式，用 OpenGL 播放</span></div><div class="line">                    <span class="comment">//OpenGL GPU渲染</span></div><div class="line">                    [<span class="keyword">self</span> makeYUVframe];</div><div class="line">                    </div><div class="line">                    <span class="comment">//imageView播放，我们将解码获得的 YUV 数据解码为 image，然后交给 imageview</span></div><div class="line"><span class="comment">//                    [self makeImage];</span></div><div class="line">                    </div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            av_free_packet(packet);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//最后释放我们用到的结构体</span></div><div class="line">        sws_freeContext(img_convert_ctx);</div><div class="line">        av_frame_free(&amp;pFrameYUV);</div><div class="line">        av_frame_free(&amp;pFrame);</div><div class="line">        avcodec_close(pCodecCtx);</div><div class="line">        avformat_close_input(&amp;pFormatCtx);</div><div class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:decodeDidFinishNotification object:nil];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="播放部分"><a href="#播放部分" class="headerlink" title="播放部分"></a>播放部分</h1><h2 id="OpenGL播放"><a href="#OpenGL播放" class="headerlink" title="OpenGL播放"></a>OpenGL播放</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YUV转RGB</span></div><div class="line">- (void)makeYUVframe&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="title">unsigned</span> int lumaLength = (pCodecCtx-&gt;</span><span class="function"><span class="title">height</span>)*(MIN(pFrame-&gt;</span><span class="function"><span class="title">linesize</span>[0], pCodecCtx-&gt;</span>width));</div><div class="line">    <span class="function"><span class="title">unsigned</span> int chromBLength = ((pCodecCtx-&gt;</span><span class="function"><span class="title">height</span>)/2)*(MIN(pFrame-&gt;</span><span class="function"><span class="title">linesize</span>[1], (pCodecCtx-&gt;</span>width)/<span class="number">2</span>));</div><div class="line">    <span class="function"><span class="title">unsigned</span> int chromRLength = ((pCodecCtx-&gt;</span><span class="function"><span class="title">height</span>)/2)*(MIN(pFrame-&gt;</span><span class="function"><span class="title">linesize</span>[1], (pCodecCtx-&gt;</span>width)/<span class="number">2</span>));</div><div class="line">    </div><div class="line">    <span class="comment">//初始化</span></div><div class="line">    H264YUV_Frame yuvFrame;</div><div class="line">    </div><div class="line">    <span class="comment">//此函数的意思是将 sizeof(H264YUV_Frame) 大小的 0 数据，拷贝到这个地址&amp;yuvFrame 实际上就是初始化</span></div><div class="line">    memset(&amp;yuvFrame, <span class="number">0</span>, sizeof(H264YUV_Frame));</div><div class="line">    </div><div class="line">    yuvFrame.luma.length = lumaLength;</div><div class="line">    yuvFrame.chromaB.length = chromBLength;</div><div class="line">    yuvFrame.chromaR.length = chromRLength;</div><div class="line">    </div><div class="line">    yuvFrame.luma.dataBuffer = (unsigned char*)malloc(lumaLength);</div><div class="line">    yuvFrame.chromaB.dataBuffer = (unsigned char*)malloc(chromBLength);</div><div class="line">    yuvFrame.chromaR.dataBuffer = (unsigned char*)malloc(chromRLength);</div><div class="line">    </div><div class="line">    <span class="comment">//转RGB</span></div><div class="line">    <span class="function"><span class="title">copyDecodedFrame</span>(pFrame-&gt;</span><span class="function"><span class="title">data</span>[0], yuvFrame.luma.dataBuffer, pFrame-&gt;</span><span class="function"><span class="title">linesize</span>[0], pCodecCtx-&gt;</span><span class="function"><span class="title">width</span>, pCodecCtx-&gt;</span>height);</div><div class="line">    <span class="function"><span class="title">copyDecodedFrame</span>(pFrame-&gt;</span><span class="function"><span class="title">data</span>[1], yuvFrame.chromaB.dataBuffer, pFrame-&gt;</span><span class="function"><span class="title">linesize</span>[1], pCodecCtx-&gt;</span><span class="function"><span class="title">width</span>/2, pCodecCtx-&gt;</span>height/<span class="number">2</span>);</div><div class="line">    <span class="function"><span class="title">copyDecodedFrame</span>(pFrame-&gt;</span><span class="function"><span class="title">data</span>[2], yuvFrame.chromaR.dataBuffer, pFrame-&gt;</span><span class="function"><span class="title">linesize</span>[2], pCodecCtx-&gt;</span><span class="function"><span class="title">width</span>/2, pCodecCtx-&gt;</span>height/<span class="number">2</span>);</div><div class="line">    </div><div class="line">    <span class="function"><span class="title">yuvFrame</span>.width = pCodecCtx-&gt;</span>width;</div><div class="line">    <span class="function"><span class="title">yuvFrame</span>.height = pCodecCtx-&gt;</span>height;</div><div class="line">    </div><div class="line">    <span class="comment">//在主线程中把获得到的 RGB 更新出去，这里通过代理</span></div><div class="line">    dispatch_sync(dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>([self.delegate respondsToSelector:@selector(updateYUVFrameOnMainThread:)])&#123;</div><div class="line">            [self.delegate updateYUVFrameOnMainThread:(H264YUV_Frame *)&amp;yuvFrame];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="comment">//最后释放</span></div><div class="line">    free(yuvFrame.luma.dataBuffer);</div><div class="line">    free(yuvFrame.chromaB.dataBuffer);</div><div class="line">    free(yuvFrame.chromaR.dataBuffer);</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//转RGB算法</span></div><div class="line">void copyDecodedFrame(unsigned char *src, unsigned char *dist,int linesize, int width, int height)</div><div class="line">&#123;</div><div class="line">    </div><div class="line">    width = MIN(linesize, width);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (NSUInteger i = <span class="number">0</span>; i &lt; height; ++i) &#123;</div><div class="line">        memcpy(dist, src, width);</div><div class="line">        dist += width;</div><div class="line">        src += linesize;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的 OpenGL 播放我用的是前辈写的 OpenGL 播放器，只需要传入RGB 数据就可以播放了，下面是代理方法的实现<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#pragma</span> <span class="selector-tag">mark</span> <span class="selector-tag">------</span> <span class="selector-tag">LLQH264DecoderDelegate</span></div><div class="line"></div><div class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">updateYUVFrameOnMainThread</span><span class="selector-pseudo">:(H264YUV_Frame</span> *)<span class="selector-tag">yuvFrame</span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//只需要调用这个方法，就可以播放了</span></div><div class="line">    <span class="selector-attr">[_openGLFrameView render:yuvFrame]</span>;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="imageView播放"><a href="#imageView播放" class="headerlink" title="imageView播放"></a>imageView播放</h2><p>同样是利用代理方法将获得的图片更新出去<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//转为image</span></div><div class="line">- (<span class="keyword">void</span>)makeImage&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//给picture分配空间</span></div><div class="line">    <span class="built_in">AVPicture</span> pictureL = [<span class="keyword">self</span> AllocAVPicture];</div><div class="line">    <span class="keyword">int</span> pictRet = sws_scale (img_convert_ctx,(<span class="keyword">const</span> uint8_t * <span class="keyword">const</span> *)pFrame-&gt;data, pFrame-&gt;linesize,</div><div class="line">                             <span class="number">0</span>, pCodecCtx-&gt;height,</div><div class="line">                             pictureL.data, pictureL.linesize);</div><div class="line">    <span class="keyword">if</span> (pictRet &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">UIImage</span> * image = [<span class="keyword">self</span> imageFromAVPicture:pictureL width:pCodecCtx-&gt;width height:pCodecCtx-&gt;height];</div><div class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1.0</span>/<span class="number">80.0</span>];</div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(updateImageOnMainTread:)]) &#123;</div><div class="line">            [<span class="keyword">self</span>.delegate updateImageOnMainTread:image];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    <span class="comment">//释放AVPicture</span></div><div class="line">    avpicture_free(&amp;pictureL);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这边是一些转为image用到的算法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-(<span class="built_in">AVPicture</span>)AllocAVPicture</div><div class="line">&#123;</div><div class="line">    <span class="comment">//创建AVPicture</span></div><div class="line">    <span class="built_in">AVPicture</span> pictureL;</div><div class="line">    sws_freeContext(img_convert_ctx);</div><div class="line">    avpicture_alloc(&amp;pictureL, PIX_FMT_RGB24,pCodecCtx-&gt;width,pCodecCtx-&gt;height);</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sws_flags =  SWS_FAST_BILINEAR;</div><div class="line">    img_convert_ctx = sws_getContext(pCodecCtx-&gt;width,</div><div class="line">                                     pCodecCtx-&gt;height,</div><div class="line">                                     pCodecCtx-&gt;pix_fmt,</div><div class="line">                                     pCodecCtx-&gt;width,</div><div class="line">                                     pCodecCtx-&gt;height,</div><div class="line">                                     PIX_FMT_RGB24,</div><div class="line">                                     sws_flags, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">return</span> pictureL;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**AVPicture转UIImage*/</span></div><div class="line">-(<span class="built_in">UIImage</span> *)imageFromAVPicture:(<span class="built_in">AVPicture</span>)pict width:(<span class="keyword">int</span>)width height:(<span class="keyword">int</span>)height &#123;</div><div class="line">    <span class="built_in">CGBitmapInfo</span> bitmapInfo = kCGBitmapByteOrderDefault;</div><div class="line">    <span class="built_in">CFDataRef</span> data = <span class="built_in">CFDataCreateWithBytesNoCopy</span>(kCFAllocatorDefault, pict.data[<span class="number">0</span>], pict.linesize[<span class="number">0</span>]*height,kCFAllocatorNull);</div><div class="line">    <span class="built_in">CGDataProviderRef</span> provider = <span class="built_in">CGDataProviderCreateWithCFData</span>(data);</div><div class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</div><div class="line">    <span class="built_in">CGImageRef</span> cgImage = <span class="built_in">CGImageCreate</span>(width,</div><div class="line">                                       height,</div><div class="line">                                       <span class="number">8</span>,</div><div class="line">                                       <span class="number">24</span>,</div><div class="line">                                       pict.linesize[<span class="number">0</span>],</div><div class="line">                                       colorSpace,</div><div class="line">                                       bitmapInfo,</div><div class="line">                                       provider,</div><div class="line">                                       <span class="literal">NULL</span>,</div><div class="line">                                       <span class="literal">NO</span>,</div><div class="line">                                       kCGRenderingIntentDefault);</div><div class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithCGImage:cgImage];</div><div class="line">    <span class="built_in">CGImageRelease</span>(cgImage);</div><div class="line">    <span class="built_in">CGDataProviderRelease</span>(provider);</div><div class="line">    <span class="built_in">CFRelease</span>(data);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> image;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代理方法的实现，只需要将图片交给 imageView<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark ------ LLQH264DecoderDelegate</span></div><div class="line">- (<span class="keyword">void</span>)updateImageOnMainTread:(UIImage *)<span class="built_in">image</span>&#123;</div><div class="line">    </div><div class="line">    dispatch_sync(dispatch_get_main_queue(), ^&#123;</div><div class="line">       </div><div class="line">        _imageView.<span class="built_in">image</span> = <span class="built_in">image</span>;</div><div class="line">        </div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="https://github.com/li1024316925/DecodeH264" target="_blank" rel="external">最后附上源码地址</a><br>这个解码还是比较简单的，需要静下心来研究一下</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近学习 FFmpeg，自己写了一个小 Demo 解码一个 H.264 裸流数据&lt;br&gt;FFmpeg 的编译导入等工作我们不再赘述，下面直接进入正题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;导入库文件&lt;br&gt;&lt;figure class=&quot;high
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>通过拦截hitTest:withEvent方法，解决超出父视图的子视图不能接受点击事件的问题</title>
    <link href="http://yoursite.com/2016/12/14/%E9%80%9A%E8%BF%87%E6%8B%A6%E6%88%AAhitTest-withEvent%E6%96%B9%E6%B3%95%EF%BC%8C%E8%A7%A3%E5%86%B3%E8%B6%85%E5%87%BA%E7%88%B6%E8%A7%86%E5%9B%BE%E7%9A%84%E5%AD%90%E8%A7%86%E5%9B%BE%E4%B8%8D%E8%83%BD%E6%8E%A5%E5%8F%97%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2016/12/14/通过拦截hitTest-withEvent方法，解决超出父视图的子视图不能接受点击事件的问题/</id>
    <published>2016-12-14T13:46:46.000Z</published>
    <updated>2017-02-27T07:45:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于项目需求，我需要在一个高度为50的控件上面创建一个下拉菜单，效果如下<br><img src="http://upload-images.jianshu.io/upload_images/1393645-7615f6291d98befb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="screenshot.png"><br>当我做完之后发现，下拉菜单的下拉选择项不能点击<br><img src="http://upload-images.jianshu.io/upload_images/1393645-95c2565295819887.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="screenshot.png"><br>这是因为我们的控件高度只有50，但是下拉菜单的高度超出了控件的大小，这样，我们就接受不到点击事件了<br>这边找了一个比较详细的图，来描述事件的分发<br><img src="http://upload-images.jianshu.io/upload_images/1393645-f33f808a87360846.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="226702-dd53b5a6df2f3ea5.png"><br>每个 view 都会有</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (UIView *)<span class="string">hitTest:</span>(CGPoint)point <span class="string">withEvent:</span>(UIEvent *)event&#123;</div><div class="line">    </div><div class="line">    UIView *view = [<span class="keyword">super</span> <span class="string">hitTest:</span>point <span class="string">withEvent:</span>event];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> view;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样一个方法<br>这个方法会判断当前点击的“点”是否在本 view 上，如果在本 view 上，就继续寻找本 view 的 Subview，还是通过此方法判断点击的“点”是否在 Subview 上，直到找完所有的 Subview，然后这个方法就会 return 这个最终的 Subview 并一层层的向上传递给 UIWindow，这样我们就拿到了屏幕上面最终响应的 view。</p>
<p>回到我们最开始遇到的问题。</p>
<p>由于我们下拉菜单超出了我们的自定义控件，当我们点击到下拉菜单时，从 UIWindow 开始通过 <code>hitTest</code> 方法向下寻找响应的 view，当查找到我们的自定义控件时，就会 return 了，因为我们点击的“点”已经超出了自定义控件，也就是说，这个“点”不在我们的自定义控件上，所以在自定义控件上面的下拉菜单无论如何也不会响应。</p>
<p>所以，我们只要手动的去 return 我们的下拉菜单，手动的去连接起这个 响应 view 的链，我们的下拉菜单就能响应</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">- (UIView *)<span class="string">getTargetView:</span>(UIView *)view <span class="string">point:</span>(CGPoint)point <span class="string">event:</span>(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    </div><div class="line">    __block UIView *subView;</div><div class="line">    </div><div class="line">    <span class="comment">//逆序 由层级最低 也就是最上层的子视图开始</span></div><div class="line">    [view.subviews <span class="string">enumerateObjectsWithOptions:</span>NSEnumerationReverse <span class="string">usingBlock:</span>^(__kindof UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">        <span class="comment">//point 从view 转到 obj中</span></div><div class="line">        CGPoint hitPoint = [obj <span class="string">convertPoint:</span>point <span class="string">fromView:</span>view];</div><div class="line">        <span class="comment">//        NSLog(@"%@ - %@",NSStringFromCGPoint(point),NSStringFromCGPoint(hitPoint));</span></div><div class="line">        </div><div class="line">        <span class="keyword">if</span>([obj <span class="string">pointInside:</span>hitPoint <span class="string">withEvent:</span>event])<span class="comment">//在当前视图范围内</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(obj.subviews.count != <span class="number">0</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="comment">//如果有子视图 递归</span></div><div class="line">                subView = [self <span class="string">getTargetView:</span>obj <span class="string">point:</span>hitPoint <span class="string">event:</span>event];</div><div class="line">                </div><div class="line">                <span class="keyword">if</span>(!subView)</div><div class="line">                &#123;</div><div class="line">                    <span class="comment">//如果没找到 提交当前视图</span></div><div class="line">                    subView = obj;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">                subView = obj;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            *stop = YES;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span><span class="comment">//不在当前视图范围内</span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(obj.subviews.count != <span class="number">0</span>)</div><div class="line">            &#123;</div><div class="line">                <span class="comment">//如果有子视图 递归</span></div><div class="line">                subView = [self <span class="string">getTargetView:</span>obj <span class="string">point:</span>hitPoint <span class="string">event:</span>event];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> subView;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法的目的就是找到点击的“点”最终所在的 subview，然后 return。</p>
<p>我们再回到我们的响应链断掉的地方，也就是自定义控件内的 <code>hitTest</code> 方法</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (UIView *)<span class="string">hitTest:</span>(CGPoint)point <span class="string">withEvent:</span>(UIEvent *)event&#123;</div><div class="line">    </div><div class="line">    UIView *view = [<span class="keyword">super</span> <span class="string">hitTest:</span>point <span class="string">withEvent:</span>event];</div><div class="line">  </div><div class="line">    <span class="comment">//由于响应链在此处断开，我们就去手动寻找最终响应的子视图，传入本 view 遍历本 view 的子视图</span></div><div class="line">    UIView *tempview = [self <span class="string">getTargetView:</span>self <span class="string">point:</span>point <span class="string">event:</span>event];</div><div class="line">    <span class="keyword">if</span> (tempview) &#123;</div><div class="line">        view = tempview;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> view;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>手动找到点击的点所在的 subview，并在断开的地方 return，这样我们的下拉菜单就能响应点击了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于项目需求，我需要在一个高度为50的控件上面创建一个下拉菜单，效果如下&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1393645-7615f6291d98befb.png?imageMogr2/a
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Swift3.0利用Runtime简单封装一个字典转模型</title>
    <link href="http://yoursite.com/2016/11/16/Swift3-0%E5%88%A9%E7%94%A8Runtime%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E5%AD%97%E5%85%B8%E8%BD%AC%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2016/11/16/Swift3-0利用Runtime简单封装一个字典转模型/</id>
    <published>2016-11-16T10:12:00.000Z</published>
    <updated>2017-02-27T07:38:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>在通常的项目中，我们经常会用到字典转 model 的操作，我们可以使用系统的<br><code>setValuesForKeys</code>（Swift）<br><code>setValuesForKeysWithDictionary</code>（OC）<br>方法来完成这一操作，但是这样就会遇到一个问题，如果我们数据字典其中的一个 key 与系统关键字重名，那我们在model中使用这个 key 作为属性就会报错，为了解决这一问题，我们会使用一些第三方库去完成字典转模型的操作，例如 MJExtension ，在这里，我们自己去封装一个简单的字典转模型，闲话不多说，我们马上开始。</p>
<p>首先我们去创建一个 BaseModel 类，我们在这个根类中去实现一个可以字典转自身属性的构造方法，只要我们自定义的 model 都继承这个 BaseModel 那么我们的 model 就都能使用这个构造方法完成字典转模型的操作啦~<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseModel</span>: <span class="title">NSObject</span> </span>&#123; </div><div class="line">    <span class="comment">//自定义构造方法</span></div><div class="line">    <span class="keyword">init</span>(dic: [<span class="type">String</span>:<span class="type">Any</span>]) &#123;</div><div class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在，我们已经通过构造方法，拿到了数据字典，那么接下来我们只要将字典的键值对转换为我们自身的属性，就大功告成啦~<br>我们写一个新的方法，去完成这个操作<br>我们首先在这个方法中使用 Runtime 获取一下本类的所有属性<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">setAttribut</span><span class="params">(dic: [String:Any])</span></span> -&gt; <span class="type">Void</span> &#123;</div><div class="line">        <span class="comment">//Runtime获取本类属性</span></div><div class="line">        <span class="keyword">var</span> <span class="built_in">count</span>:<span class="type">UInt32</span> = <span class="number">0</span></div><div class="line">        <span class="keyword">let</span> ivars = class_copyIvarList(<span class="keyword">self</span>.classForCoder, &amp;<span class="built_in">count</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后我们遍历这个获取到的属性数组，取出其中的元素，并获得属性名，这里值得注意的是，我们获得的属性名是 C 语言字符串，这里我们要转换一下变成 Swift 字符串<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>.&lt;count &#123;</div><div class="line">         <span class="comment">//取出属性名</span></div><div class="line">         <span class="keyword">let</span> ivar = ivars?[Int(i)]</div><div class="line">         <span class="keyword">let</span> ivarName = ivar_getName(ivar!)</div><div class="line">         <span class="keyword">let</span> nName = <span class="built_in">String</span>(cString: ivarName!)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>进行到这一步，相信很多小伙伴已经明白其中的原理了，接下来，我们只要利用取到的属性名从我们的数据字典中取到相应的 value 然后赋值给我们的属性，我们的任务就完成了，但是这里，我们要解决我们刚开始遇到问题 “我们的属性名和字典的key值必须不相同怎么办？” 在这里我的解决办法是重新建立一个 model 属性与字典 key 值的映射关系，这里又写了一个建立映射的方法<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果属性名与数据字典的key值不对应，那么在子类model中复写此方法，将属性名作为key，字典key值作为value</span></div><div class="line">    func attributesDic(dic: <span class="type"></span>[<span class="keyword">String</span>:<span class="type">Any</span>]) -&gt; [<span class="keyword">String</span>:<span class="type">String</span>] &#123;</div><div class="line">        <span class="keyword">var</span> <span class="keyword">new</span><span class="type">Dic</span>:[<span class="keyword">String</span>:<span class="type">String</span>] = [:<span class="type"></span>]</div><div class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> dic.keys &#123;</div><div class="line">            <span class="comment">//复写时注意将属性名作为key 数据字典的key作为value</span></div><div class="line">            <span class="keyword">new</span><span class="type">Dic</span>[key] = key</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Dic</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>在这个 BaseModel 父类中，我们先让数据字典所有的 key 映射为 key 本身，这样我们在复写这个方法时只修改 key 与属性不对应的映射就可以了。<br><strong>这里有特别注意的一点，在复写时，我们一定要用 super 首先调用一下这个方法。</strong></p>
<p>这样，我们的属性赋值方法就要修改了，我们要首先拿到数据字典的 key 与属性的全新映射关系<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">setAttribut</span><span class="params">(dic: [String:Any])</span></span> -&gt; <span class="type">Void</span> &#123;</div><div class="line">        <span class="comment">//获得映射关系</span></div><div class="line">        <span class="keyword">let</span> attributDic = attributesDic(dic: dic)        </div><div class="line">        <span class="comment">//Runtime获取本类属性</span></div><div class="line">        <span class="keyword">var</span> <span class="built_in">count</span>:<span class="type">UInt32</span> = <span class="number">0</span></div><div class="line">        <span class="keyword">let</span> ivars = class_copyIvarList(<span class="keyword">self</span>.classForCoder, &amp;<span class="built_in">count</span>)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</div><div class="line">            <span class="comment">//取出属性名</span></div><div class="line">            <span class="keyword">let</span> ivar = ivars?[<span class="type">Int</span>(i)]</div><div class="line">            <span class="keyword">let</span> ivarName = ivar_getName(ivar!)</div><div class="line">            <span class="keyword">let</span> nName = <span class="type">String</span>(cString: ivarName!)</div><div class="line">        &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样一来我们离成功就只差一步了！！<br>我们需要将取到的属性名通过全新的映射关系取到数据字典的 key ，然后利用这个 key 从数据字典取到 value 最后将 value 赋值给我们 model  的属性<br>最后，我们的属性赋值方法变成了这样<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">setAttribut</span><span class="params">(dic: [String:Any])</span></span> -&gt; <span class="type">Void</span> &#123;</div><div class="line">        <span class="keyword">let</span> attributDic = attributesDic(dic: dic)</div><div class="line">        <span class="comment">//Runtime获取本类属性</span></div><div class="line">        <span class="keyword">var</span> <span class="built_in">count</span>:<span class="type">UInt32</span> = <span class="number">0</span></div><div class="line">        <span class="keyword">let</span> ivars = class_copyIvarList(<span class="keyword">self</span>.classForCoder, &amp;<span class="built_in">count</span>)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</div><div class="line">            <span class="comment">//取出属性名</span></div><div class="line">            <span class="keyword">let</span> ivar = ivars?[<span class="type">Int</span>(i)]</div><div class="line">            <span class="keyword">let</span> ivarName = ivar_getName(ivar!)</div><div class="line">            <span class="keyword">let</span> nName = <span class="type">String</span>(cString: ivarName!)</div><div class="line">            <span class="comment">//取出要赋值的值</span></div><div class="line">            <span class="keyword">var</span> attribut = attributDic[nName]</div><div class="line">            <span class="keyword">if</span> attribut == <span class="literal">nil</span>&#123;</div><div class="line">                attribut = <span class="string">""</span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">var</span> value:<span class="type">NSObject</span></div><div class="line">            <span class="keyword">if</span> dic[attribut!] != <span class="literal">nil</span> &#123;</div><div class="line">                value = dic[attribut!] <span class="keyword">as</span>! <span class="type">NSObject</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                value = <span class="string">""</span> <span class="keyword">as</span> <span class="type">NSObject</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//利用KVC给本类的属性赋值</span></div><div class="line">            <span class="keyword">self</span>.setValue(value, forKey: nName)   </div><div class="line">        &#125;        </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h6 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h6><p>在我们自定义的初始化方法中调用一下<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//自定义构造方法</span></div><div class="line">    <span class="selector-tag">init</span>(<span class="attribute">dic</span>: [<span class="attribute">String</span>:Any]) &#123;</div><div class="line">        <span class="selector-tag">super</span><span class="selector-class">.init</span>()</div><div class="line">        <span class="selector-tag">setAttribut</span>(<span class="attribute">dic</span>: dic)</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>大功告成！！<br>这个封装好的 model 已经在我写的 Swift 小项目中得到了验证，这是项目地址<br><a href="https://github.com/li1024316925/Swift-TimeMovie" target="_blank" rel="external">时光电影Swift版初学小项目</a><br>本文如果有什么错误或者您有更好的方法，欢迎指出</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在通常的项目中，我们经常会用到字典转 model 的操作，我们可以使用系统的&lt;br&gt;&lt;code&gt;setValuesForKeys&lt;/code&gt;（Swift）&lt;br&gt;&lt;code&gt;setValuesForKeysWithDictionary&lt;/code&gt;（OC）&lt;br&gt;方法来完
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Swift3.0版时光电影项目笔记</title>
    <link href="http://yoursite.com/2016/10/18/Swift3.0%E7%89%88%E6%97%B6%E5%85%89%E7%94%B5%E5%BD%B1%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/10/18/Swift3.0版时光电影项目笔记/</id>
    <published>2016-10-18T05:03:04.000Z</published>
    <updated>2017-02-27T07:33:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>Swift 刚学几天，以练手的心态改写以前一个 OC 的小项目，这里记录一些遇到的坑点。由于是初学者，各位大牛如果发现错误，欢迎指出。闲话不多说，下面就正式开始</p>
<h1 id="1-私有属性和方法"><a href="#1-私有属性和方法" class="headerlink" title="1.私有属性和方法"></a>1.私有属性和方法</h1><p>在 Swift 中，是没有私有属性的，也就是说，只要在同一个命名空间（后面会有介绍），我们都可以访问的到。但是Swift中是有有 private 关键字的，根据特点决定，如果编写 App 的话，直接用默认的就好了，就是啥也不用敲，如果编写 Framework，请认真思考流程，认真设计，外部接口要设置 public，而一些不想让别人看见的就可以用 private 或者 internal 修饰了</p>
<h1 id="2-Swift中的宏定义"><a href="#2-Swift中的宏定义" class="headerlink" title="2.Swift中的宏定义"></a>2.Swift中的宏定义</h1><p>在Swift中是没有宏定义的，但是我们可以使用公用函数来替代宏，比如<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func kTabBarWidth(<span class="class"><span class="keyword">object</span></span>: <span class="type">UITabBarController</span>) -&gt; <span class="type">CGFloat</span> &#123;<span class="keyword">return</span> <span class="class"><span class="keyword">object</span>.<span class="title">tabBar</span>.<span class="title">frame</span>.<span class="title">size</span>.<span class="title">width</span>&#125;</span></div><div class="line">func kTabBarHeight(<span class="class"><span class="keyword">object</span></span>: <span class="type">UITabBarController</span>) -&gt; <span class="type">CGFloat</span> &#123;<span class="keyword">return</span> <span class="class"><span class="keyword">object</span>.<span class="title">tabBar</span>.<span class="title">frame</span>.<span class="title">size</span>.<span class="title">height</span>&#125;</span></div><div class="line">func kButtonWidth(<span class="class"><span class="keyword">object</span></span>: <span class="type">UITabBarController</span>) -&gt; <span class="type">CGFloat</span> &#123;<span class="keyword">return</span> kTabBarWidth(<span class="class"><span class="keyword">object</span></span>: <span class="class"><span class="keyword">object</span>)<span class="title">/CGFloat</span>(<span class="params">(object.viewControllers?.count</span>)<span class="title">!</span>)&#125;</span></div></pre></td></tr></table></figure></p>
<p>在公用函数中取不到的变量我们可以以参数的形式传入</p>
<h1 id="3-Swift-中不同类型变量的运算"><a href="#3-Swift-中不同类型变量的运算" class="headerlink" title="3.Swift 中不同类型变量的运算"></a>3.Swift 中不同类型变量的运算</h1><p>Swift 是强语言，如果两个不同类型的相加，必须进行类型转换，比如<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> <span class="attr">num1</span> = <span class="number">10</span></div><div class="line"><span class="keyword">let</span> <span class="attr">num2</span> = <span class="number">9.9</span></div><div class="line"><span class="keyword">let</span> <span class="attr">iSum</span> = num1 + Int(num2)</div><div class="line"><span class="keyword">let</span> <span class="attr">dSum</span> = Double(num1) + num2</div></pre></td></tr></table></figure></p>
<h1 id="4-按钮添加点击事件"><a href="#4-按钮添加点击事件" class="headerlink" title="4.按钮添加点击事件"></a>4.按钮添加点击事件</h1><p>为按钮添加点击事件，这里使用的是#Selector(方法名)的样式<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//按钮添加点击事件</span></div><div class="line"><span class="selector-tag">button</span>.addTarget(self, action: #selector(selectedVC(<span class="selector-tag">button</span>:)), <span class="keyword">for</span>: UIControlEvents.touchUpInside)</div></pre></td></tr></table></figure></p>
<p>值得注意的是，我们后面的按钮点击方式的枚举类型应该用<br>枚举名+“.”+枚举值<br>的方式来调用</p>
<h1 id="5-闭包中的self与循环引用"><a href="#5-闭包中的self与循环引用" class="headerlink" title="5.闭包中的self与循环引用"></a>5.闭包中的self与循环引用</h1><p>Swift 中的闭包，也就是 OC 中的 Block ，怎么使用这里就不多叙述了，我们这里要说的，是要特别注意的点<br>在闭包中使用本类的属性或调用方法，必须使用Self调用，这样的话，就产生了循环引用的问题，和OC中相差不多，我们利用一个 weak 关键字来解决这一问题<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let homeViewModel = HomeViewModel()</div><div class="line">weak <span class="selector-tag">var</span> weakSelf = self</div><div class="line">homeViewModel<span class="selector-class">.loadMovieData</span> &#123; (data) <span class="keyword">in</span></div><div class="line">    weakSelf!<span class="selector-class">.dataList</span> = data</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="6-Swift中的命名空间"><a href="#6-Swift中的命名空间" class="headerlink" title="6.Swift中的命名空间"></a>6.Swift中的命名空间</h1><p>Objective-C 是没有命名空间的，在应用开发时，所有的代码和引用的静态库最终都会被编译到同一个域和二进制中。这样的后果是一旦我们有重复的类名的话，就会导致编译时的冲突和失败。在 Swift 中，由于可以使用命名空间了，即使是名字相同的类型，只要是来自不同的命名空间的话，都是可以和平共处的。Swift 中的命名空间的使用不是一个项目,而是需要跨项目,在一个项目中,都是一个命名空间,在同一个命名空间下,所有全局变量或者函数共享,不需要 import<br>我们项目中使用到了命名空间，在我们动态创建控制器的时候<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> imgNames = [<span class="string">"home"</span>,<span class="string">"payticket"</span>,<span class="string">"store"</span>,<span class="string">"discover"</span>,<span class="string">"myinfo"</span>]</div><div class="line"><span class="comment">//创建标签控制器数组存储标签控制器名</span></div><div class="line"><span class="keyword">let</span> viewContorllersArray = [<span class="string">"HomeViewController"</span>,<span class="string">"PayTicketViewController"</span>,<span class="string">"StoreViewController"</span>,<span class="string">"DiscoverViewController"</span>,<span class="string">"MyInfoViewController"</span>]</div><div class="line">        </div><div class="line">var bnvVcArray:[UIViewController] = []</div><div class="line">        </div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>.&lt;<span class="number">5</span> &#123;</div><div class="line">    <span class="keyword">let</span> str = viewContorllersArray[i]</div><div class="line">    <span class="comment">//通过一个字符串创建控制器对象</span></div><div class="line">    <span class="comment">//获取命名空间</span></div><div class="line">    <span class="comment">//namespace在info.plist 对应的是 CFBundleExecutable,我们可以在info.plist中任意右击一行,选中Show Raw Keys/Values</span></div><div class="line">    <span class="keyword">let</span> <span class="keyword">namespace</span> = Bundle.main.infoDictionary![<span class="string">"CFBundleExecutable"</span>] <span class="keyword">as</span>! String</div><div class="line">    <span class="keyword">let</span> uivcType = NSClassFromString(<span class="keyword">namespace</span> + <span class="string">"."</span> + str) <span class="keyword">as</span>? UIViewController.Type</div><div class="line">    <span class="comment">//可选绑定</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="class"><span class="keyword">type</span> </span>= uivcType &#123;</div><div class="line">        <span class="comment">//创建</span></div><div class="line">        <span class="keyword">let</span> uiVC = <span class="class"><span class="keyword">type</span>.<span class="title">init</span></span>()</div><div class="line">        uiVC.tabBarItem.selectedImage = UIImage(named: imgNames[i] + <span class="string">"_on"</span>)</div><div class="line">        uiVC.tabBarItem.image = UIImage(named: imgNames[i])</div><div class="line">        uiVC.title = imgNames[i]</div><div class="line">        <span class="keyword">let</span> bnv = BaseNavViewController(rootViewController: uiVC)</div><div class="line">        bnvVcArray.append(bnv)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果新建项目时，项目名称中包含有中文，可以进入是 Build Settings 中选中 “All” ，搜索 product name ，即可修改命名空间，如图:<br><img src="http://upload-images.jianshu.io/upload_images/1393645-21279dec8e9096b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2373BC66-3171-4EE9-998F-D715DD43D680.png"></p>
<h1 id="7-使用-Runtime-实现字典转模型"><a href="#7-使用-Runtime-实现字典转模型" class="headerlink" title="7.使用 Runtime 实现字典转模型"></a>7.使用 Runtime 实现字典转模型</h1><p>我们在项目中自定义了一个 BaseModel 自定义了一个构造方法传入一个字典，来方便的实现字典转模型，在实现过程中，我们在 Swift 中使用了 Runtime<br>我们知道 OC 是动态语言，能够通过 runtime API 调用和替换任意方法，纯 Swift 类的函数调用已经不再是 OC 的运行时发消息，而是在编译时就确定了调用哪个函数，所以没法通过 runtime 获取方法、属性，而Swift为了兼容 OC ，凡是继承自 NSObject 的类都会保留其动态性，所以我们能通过 runtime 拿到继承与 NSObject 的类的方法和属性<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">setAttribut</span><span class="params">(dic: [String:Any])</span></span> -&gt; <span class="type">Void</span> &#123;</div><div class="line">    <span class="keyword">let</span> attributDic = attributesDic(dic: dic)</div><div class="line">    </div><div class="line">    <span class="comment">//Runtime获取本类属性</span></div><div class="line">    <span class="keyword">var</span> <span class="built_in">count</span>:<span class="type">UInt32</span> = <span class="number">0</span></div><div class="line">    <span class="keyword">let</span> ivars = class_copyIvarList(<span class="keyword">self</span>.classForCoder, &amp;<span class="built_in">count</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</div><div class="line">        <span class="comment">//取出属性名</span></div><div class="line">        <span class="keyword">let</span> ivar = ivars?[<span class="type">Int</span>(i)]</div><div class="line">        <span class="keyword">let</span> ivarName = ivar_getName(ivar!)</div><div class="line">        <span class="keyword">let</span> nName = <span class="type">String</span>(cString: ivarName!)</div><div class="line">        <span class="comment">//取出要赋值的值</span></div><div class="line">        <span class="keyword">let</span> attribut = attributDic[nName]</div><div class="line">        <span class="keyword">var</span> value:<span class="type">NSObject</span></div><div class="line">        <span class="keyword">if</span> dic[attribut!] != <span class="literal">nil</span> &#123;</div><div class="line">            value = dic[attribut!] <span class="keyword">as</span>! <span class="type">NSObject</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            value = <span class="string">""</span> <span class="keyword">as</span> <span class="type">NSObject</span></div><div class="line">        &#125;   </div><div class="line"> </div><div class="line">        <span class="comment">//利用KVC给本类的属性赋值</span></div><div class="line">        <span class="keyword">self</span>.setValue(value, forKey: nName)</div><div class="line">           </div><div class="line">    &#125;</div><div class="line">        </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="8-Swift-中的异常处理"><a href="#8-Swift-中的异常处理" class="headerlink" title="8.Swift 中的异常处理"></a>8.Swift 中的异常处理</h1><p>在 OC 中调用方法时，通常是通过一个 NSError 参数来返回异常信息的，但是在Swift中返回异常的方式就有些不同了。下面，我们自定义一个返回异常的函数，并且调用这个函数<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义一个抛出异常的方法</span></div><div class="line"><span class="comment">//在一切正常的情况下，返回值是String类型，</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionWhichCanFail</span><span class="params">(param: Int)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">String</span> &#123;       </div><div class="line">    <span class="keyword">if</span> param &gt; <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"成功"</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="type">NSError</span>(domain: <span class="string">"啦啦啦，失败了"</span>, code: <span class="number">499</span>, userInfo: <span class="literal">nil</span>)</div><div class="line">    &#125;   </div><div class="line">&#125;</div><div class="line"><span class="comment">//do-try-catch这种错误模式，本意就是尝试（try）做一件事情，如果失败则捕获（catch）处理。</span></div><div class="line"><span class="comment">//要注意的是你可以在 do 代码段中写多于一行的代码(并且 try 可以调用不止一个抛错误的方法)。如果一切顺利的话，将会像预期的那样执行那些方法，但是一旦方法出错就会跳出 do 代码段，进入 catch 处。</span></div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    <span class="comment">//尝试做一件事情</span></div><div class="line">    <span class="keyword">let</span> result = <span class="keyword">try</span> someFunctionWhichCanFail(param: -<span class="number">1</span>)</div><div class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(result)</span>"</span>)</div><div class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> error &#123;</div><div class="line">    <span class="comment">//在catch中捕获错误信息</span></div><div class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">\(error)</span>"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样，我们就基本明白了 Swift 中处理异常的基本方式，再看我们的项目。<br>在项目中，我们封装了一个JSON文件解析类，这个类有一个方法，传入JSON文件名，返回一个解析好的字典或是数组<br><figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">jsonObjectFromFileName</span>(<span class="title">fileName</span>: <span class="title">String</span>) -&gt; <span class="title">NSDictionary</span>? &#123;</span></div><div class="line">    <span class="comment">//获取文件路径</span></div><div class="line">    <span class="keyword">let</span> path = <span class="type">Bundle</span>.main.path(forResource: fileName, ofType: <span class="string">"json"</span>)</div><div class="line">    <span class="comment">//解析</span></div><div class="line">    <span class="keyword">let</span> data = <span class="type">NSData</span>.init(contentsOfFile: path!)</div><div class="line">    <span class="keyword">let</span> dic = <span class="keyword">try</span>! <span class="type">JSONSerialization</span>.jsonObject(<span class="keyword">with</span>: data! <span class="keyword">as</span> <span class="type">Data</span>, options: <span class="type">JSONSerialization</span>.<span class="type">ReadingOptions</span>.allowFragments) <span class="keyword">as</span>? <span class="type">NSDictionary</span></div><div class="line">        </div><div class="line">    <span class="keyword">return</span> dic</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的<br>JSONSerialization.jsonObject(with: data! as Data, options: JSONSerialization.ReadingOptions.allowFragments)<br>方法是要求我们必须捕获一个异常的，我们这里代码中使用了一个 try! 关键字，这里还可以使用 try? 关键字。try? 会将错误转换为可选值，当调用 try? ＋函数或方法语句 的时候，如果函数或方法抛出错误，程序不会发崩溃，而返回一个nil，如果没有抛出错误则返回可选值，不会含有更多的造成特定的错误或者异常原因的信息。try! 打破了错误传播链条，但是如果真的发生错误就出现运行期错误，导致程序的崩溃。所以使用 try! 打破错误传播链条时，应该确保程序不会发生错误</p>
<h1 id="9-Swift-项目中使用-CocoaPods"><a href="#9-Swift-项目中使用-CocoaPods" class="headerlink" title="9.Swift 项目中使用 CocoaPods"></a>9.Swift 项目中使用 CocoaPods</h1><p>Swift 项目中使用 Cocoapods 导入第三方库，导入的过程与 OC 项目无异，但是使用时，需要创建一个 Bridging-Header.h 桥接头文件，来实现 OC 与 Swift 混编<br><img src="http://upload-images.jianshu.io/upload_images/1393645-8fd9129efb896ad0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="screenshot.png"><br>可以在Building Settings中自己设置桥接头文件</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1393645-e2e655391285c0e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="screenshot 2.png"><br>这里有个简便方法生成这个桥接文件，就是我们在项目中创建一个 OC 文件，Xcode就会自动帮我们生成一个桥接头文件<br>有了头文件之后，我们只需要在桥接文件中导入我们需要使用的第三方库，就可以愉快的使用了~~~~</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1393645-b04706b707d455a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="screenshot 3.png"></p>
<h1 id="10-子类实现父类的代理方法"><a href="#10-子类实现父类的代理方法" class="headerlink" title="10.子类实现父类的代理方法"></a>10.子类实现父类的代理方法</h1><p>在这里，让我们首先看项目中的例子<br>我们声明了一个 BaseCollectionView 继承于 UICollectionView ，并将代理设置为自己<br><img src="http://upload-images.jianshu.io/upload_images/1393645-169020eb03fefbee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="screenshot.png"><br>然后我们又声明了一个 PosterCollectionView 继承了BaseCollectionView<br><img src="http://upload-images.jianshu.io/upload_images/1393645-b245fda051861ade.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="screenshot.png"><br>在 OC 中，我们想要在 PosterCollectionView 里实现 UICollectionView 的 delegate 方法，那么直接在子类 PosterCollectionView 中书写就可以了，但是在Swift中，我们需要在父类 BaseCollectionView 中实现，然后在子类 PosterCollectionView 中重写</p>
<p>父类：<br><img src="http://upload-images.jianshu.io/upload_images/1393645-25cdf09067afd92c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="screenshot.png"><br>子类：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1393645-b209ec1954c829e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="screenshot.png"></p>
<h1 id="11-Swift-中的-KVO"><a href="#11-Swift-中的-KVO" class="headerlink" title="11.Swift 中的 KVO"></a>11.Swift 中的 KVO</h1><p>Swift 中的 KVO 使用与 OC 相差不多，但是还是有一些坑点，下面我们只是简单的说一下<br>1.观察者和被观察者都必须是 NSObject 的子类，因为 OC 中 KVO 的实现基于 KVC 和 runtime 机制，只有是 NSObject 的子类才能利用这些特性<br>2.要观察的属性使用 @dynamic 修饰，表示该属性的存取都由 runtime 在运行时来决定，由于 Swift 基于效率的考量默认禁止了动态派发机制，因此要加上该修饰符来开启动态派发<br>这里是项目中的实现代码<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//被观察的属性，加dynamic关键字</span></div><div class="line"><span class="comment">//记录下标</span></div><div class="line"><span class="keyword">dynamic</span> <span class="keyword">var</span> currentIndex:<span class="built_in">Int</span> = <span class="number">0</span></div></pre></td></tr></table></figure></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//添加监听</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addObserver</span><span class="params">()</span></span> -&gt; <span class="type">Void</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//添加indexCollectionView的监听</span></div><div class="line">        indexCollectionView?.addObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"currentIndex"</span>, options: <span class="type">NSKeyValueObservingOptions</span>.new, context: <span class="literal">nil</span>)</div><div class="line">        </div><div class="line">        <span class="comment">//添加posterCollectionView的监听</span></div><div class="line">        posterCollectionView?.addObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"currentIndex"</span>, options: <span class="type">NSKeyValueObservingOptions</span>.new, context: <span class="literal">nil</span>)</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//观察者方法</span></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">observeValue</span><span class="params">(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?)</span></span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//变化后的值</span></div><div class="line">        <span class="keyword">let</span> index = change?[<span class="type">NSKeyValueChangeKey</span>.newKey] <span class="keyword">as</span>! <span class="type">Int</span></div><div class="line">        </div><div class="line">        <span class="comment">//创建indexPath</span></div><div class="line">        <span class="keyword">let</span> indexPath = <span class="type">IndexPath</span>(item: index, section: <span class="number">0</span>)</div><div class="line">        </div><div class="line">        <span class="comment">//判断是否是currenIndex属性</span></div><div class="line">        <span class="keyword">guard</span> keyPath == <span class="string">"currentIndex"</span> <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//判断对象的类型</span></div><div class="line">        <span class="keyword">if</span> object <span class="keyword">is</span> <span class="type">PosterCollectionView</span> &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//滑动到指定单元格</span></div><div class="line">            indexCollectionView?.scrollToItem(at: indexPath, at: <span class="type">UICollectionViewScrollPosition</span>.centeredHorizontally, animated: <span class="literal">true</span>)</div><div class="line">            </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> object <span class="keyword">is</span> <span class="type">IndexCollectionView</span>&#123;</div><div class="line">            </div><div class="line">            <span class="comment">//滑动到指定单元格</span></div><div class="line">            posterCollectionView?.scrollToItem(at: indexPath, at: <span class="type">UICollectionViewScrollPosition</span>.centeredHorizontally, animated: <span class="literal">true</span>)</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//变换标题</span></div><div class="line">        titleLabel?.text = dataList?[index].titleCn</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//销毁</span></div><div class="line">    <span class="keyword">deinit</span> &#123;</div><div class="line">        <span class="comment">//移除观察者</span></div><div class="line">        indexCollectionView?.removeObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"currentIndex"</span>)</div><div class="line">        posterCollectionView?.removeObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"currentIndex"</span>)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里注意一定要在析构函数中移除监听<br>如果你还对 Swift 中的 KVO 感兴趣的话，可以看一下这篇文章<br><a href="http://www.jianshu.com/p/e036e53d240e" target="_blank" rel="external">Swift: KVO 注意事项和属性观察器</a></p>
<p>在最后，放上小项目的地址，还是那句话，说再多也不如自己敲一敲<br><a href="https://github.com/li1024316925/Swift-TimeMovie" target="_blank" rel="external">时光电影Swift版初学小项目</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Swift 刚学几天，以练手的心态改写以前一个 OC 的小项目，这里记录一些遇到的坑点。由于是初学者，各位大牛如果发现错误，欢迎指出。闲话不多说，下面就正式开始&lt;/p&gt;
&lt;h1 id=&quot;1-私有属性和方法&quot;&gt;&lt;a href=&quot;#1-私有属性和方法&quot; class=&quot;heade
    
    </summary>
    
    
  </entry>
  
</feed>
